// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use gio;
use glib;
use glib::object::IsA;
use glib::translate::*;
use soup_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::ptr;
use Address;
use Message;
use SessionFeature;

glib_wrapper! {
    pub struct ProxyResolver(Interface<soup_sys::SoupProxyResolver>) @requires SessionFeature;

    match fn {
        get_type => || soup_sys::soup_proxy_resolver_get_type(),
    }
}

pub const NONE_PROXY_RESOLVER: Option<&ProxyResolver> = None;

pub trait ProxyResolverExt: 'static {
    #[cfg_attr(feature = "v2_28", deprecated)]
    fn get_proxy_async<P: IsA<Message>, Q: IsA<gio::Cancellable>, R: FnOnce(&ProxyResolver, &Message, u32, &Address) + 'static>(&self, msg: &P, async_context: &glib::MainContext, cancellable: Option<&Q>, callback: R);

    #[cfg_attr(feature = "v2_28", deprecated)]
    fn get_proxy_sync<P: IsA<Message>, Q: IsA<gio::Cancellable>>(&self, msg: &P, cancellable: Option<&Q>) -> (u32, Address);
}

impl<O: IsA<ProxyResolver>> ProxyResolverExt for O {
    fn get_proxy_async<P: IsA<Message>, Q: IsA<gio::Cancellable>, R: FnOnce(&ProxyResolver, &Message, u32, &Address) + 'static>(&self, msg: &P, async_context: &glib::MainContext, cancellable: Option<&Q>, callback: R) {
        let callback_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn callback_func<P: IsA<Message>, Q: IsA<gio::Cancellable>, R: FnOnce(&ProxyResolver, &Message, u32, &Address) + 'static>(proxy_resolver: *mut soup_sys::SoupProxyResolver, msg: *mut soup_sys::SoupMessage, arg: libc::c_uint, addr: *mut soup_sys::SoupAddress, user_data: glib_sys::gpointer) {
            let proxy_resolver = from_glib_borrow(proxy_resolver);
            let msg = from_glib_borrow(msg);
            let addr = from_glib_borrow(addr);
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            (*callback)(&proxy_resolver, &msg, arg, &addr);
        }
        let callback = Some(callback_func::<P, Q, R> as _);
        let super_callback0: Box_<R> = callback_data;
        unsafe {
            soup_sys::soup_proxy_resolver_get_proxy_async(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0, async_context.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, callback, Box_::into_raw(super_callback0) as *mut _);
        }
    }

    fn get_proxy_sync<P: IsA<Message>, Q: IsA<gio::Cancellable>>(&self, msg: &P, cancellable: Option<&Q>) -> (u32, Address) {
        unsafe {
            let mut addr = ptr::null_mut();
            let ret = soup_sys::soup_proxy_resolver_get_proxy_sync(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut addr);
            (ret, from_glib_none(addr))
        }
    }
}

impl fmt::Display for ProxyResolver {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ProxyResolver")
    }
}
