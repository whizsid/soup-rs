// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#[cfg(any(feature = "v2_38", feature = "dox"))]
use gio;
#[cfg(any(feature = "v2_42", feature = "dox"))]
use gio_sys;
use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
#[cfg(any(feature = "v2_24", feature = "dox"))]
use glib::value::SetValueOptional;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use soup_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
#[cfg(any(feature = "v2_42", feature = "dox"))]
use std::pin::Pin;
#[cfg(any(feature = "v2_42", feature = "dox"))]
use std::ptr;
#[cfg(any(feature = "v2_38", feature = "dox"))]
use Address;
use Auth;
use Message;
#[cfg(any(feature = "v2_42", feature = "dox"))]
use Request;
#[cfg(any(feature = "v2_42", feature = "dox"))]
use RequestHTTP;
#[cfg(any(feature = "v2_24", feature = "dox"))]
use SessionFeature;
use URI;

glib_wrapper! {
    pub struct Session(Object<soup_sys::SoupSession, soup_sys::SoupSessionClass, SessionClass>);

    match fn {
        get_type => || soup_sys::soup_session_get_type(),
    }
}

impl Session {
    #[cfg(any(feature = "v2_42", feature = "dox"))]
    pub fn new() -> Session {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(soup_sys::soup_session_new())
        }
    }

    //#[cfg(any(feature = "v2_42", feature = "dox"))]
    //pub fn new_with_options(optname1: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Session {
    //    unsafe { TODO: call soup_sys:soup_session_new_with_options() }
    //}
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl Default for Session {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_SESSION: Option<&Session> = None;

pub trait SessionExt: 'static {
    fn abort(&self);

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn add_feature<P: IsA<SessionFeature>>(&self, feature: &P);

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn add_feature_by_type(&self, feature_type: glib::types::Type);

    fn cancel_message<P: IsA<Message>>(&self, msg: &P, status_code: u32);

    //#[cfg(any(feature = "v2_62", feature = "dox"))]
    //fn connect_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<gio::IOStream, glib::Error>) + Send + 'static, R: FnOnce(Result<gio::IOStream, glib::Error>) + Send + 'static>(&self, uri: &mut URI, cancellable: Option<&P>, progress_callback: Q, callback: R);

    //
    //#[cfg(any(feature = "v2_62", feature = "dox"))]
    //fn connect_async_future<Q: FnOnce(Result<gio::IOStream, glib::Error>) + Send + 'static>(&self, uri: &mut URI, progress_callback: Q) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::IOStream, glib::Error>> + 'static>>;

    fn get_async_context(&self) -> Option<glib::MainContext>;

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    fn get_feature(&self, feature_type: glib::types::Type) -> Option<SessionFeature>;

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    fn get_feature_for_message<P: IsA<Message>>(&self, feature_type: glib::types::Type, msg: &P) -> Option<SessionFeature>;

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    fn get_features(&self, feature_type: glib::types::Type) -> Vec<SessionFeature>;

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn has_feature(&self, feature_type: glib::types::Type) -> bool;

    fn pause_message<P: IsA<Message>>(&self, msg: &P);

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn prefetch_dns<P: IsA<gio::Cancellable>>(&self, hostname: &str, cancellable: Option<&P>, callback: Option<Box_<dyn FnOnce(&Address, u32) + 'static>>);

    #[cfg_attr(feature = "v2_38", deprecated)]
    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn prepare_for_uri(&self, uri: &mut URI);

    fn queue_message<P: IsA<Message>>(&self, msg: &P, callback: Option<Box_<dyn FnOnce(&Session, &Message) + 'static>>);

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn redirect_message<P: IsA<Message>>(&self, msg: &P) -> bool;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn remove_feature<P: IsA<SessionFeature>>(&self, feature: &P);

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn remove_feature_by_type(&self, feature_type: glib::types::Type);

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request(&self, uri_string: &str) -> Result<Request, glib::Error>;

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request_http(&self, method: &str, uri_string: &str) -> Result<RequestHTTP, glib::Error>;

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request_http_uri(&self, method: &str, uri: &mut URI) -> Result<RequestHTTP, glib::Error>;

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request_uri(&self, uri: &mut URI) -> Result<Request, glib::Error>;

    fn requeue_message<P: IsA<Message>>(&self, msg: &P);

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn send<P: IsA<Message>, Q: IsA<gio::Cancellable>>(&self, msg: &P, cancellable: Option<&Q>) -> Result<gio::InputStream, glib::Error>;

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn send_async<P: IsA<Message>, Q: IsA<gio::Cancellable>, R: FnOnce(Result<gio::InputStream, glib::Error>) + Send + 'static>(&self, msg: &P, cancellable: Option<&Q>, callback: R);

    
    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn send_async_future<P: IsA<Message> + Clone + 'static>(&self, msg: &P) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::InputStream, glib::Error>> + 'static>>;

    fn send_message<P: IsA<Message>>(&self, msg: &P) -> u32;

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    fn steal_connection<P: IsA<Message>>(&self, msg: &P) -> Option<gio::IOStream>;

    fn unpause_message<P: IsA<Message>>(&self, msg: &P);

    //#[cfg(any(feature = "v2_50", feature = "dox"))]
    //fn websocket_connect_async<P: IsA<Message>, Q: IsA<gio::Cancellable>, R: FnOnce(Result</*Ignored*/WebsocketConnection, glib::Error>) + Send + 'static>(&self, msg: &P, origin: Option<&str>, protocols: &[&str], cancellable: Option<&Q>, callback: R);

    //
    //#[cfg(any(feature = "v2_50", feature = "dox"))]
    //fn websocket_connect_async_future<P: IsA<Message> + Clone + 'static>(&self, msg: &P, origin: Option<&str>, protocols: &[&str]) -> Pin<Box_<dyn std::future::Future<Output = Result</*Ignored*/WebsocketConnection, glib::Error>> + 'static>>;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn would_redirect<P: IsA<Message>>(&self, msg: &P) -> bool;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_property_accept_language(&self) -> Option<GString>;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_property_accept_language(&self, accept_language: Option<&str>);

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_property_accept_language_auto(&self) -> bool;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_property_accept_language_auto(&self, accept_language_auto: bool);

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_add_feature(&self) -> Option<SessionFeature>;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_add_feature<P: IsA<SessionFeature> + SetValueOptional>(&self, add_feature: Option<&P>);

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_add_feature_by_type(&self) -> glib::types::Type;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_add_feature_by_type(&self, add_feature_by_type: glib::types::Type);

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_http_aliases(&self) -> Vec<GString>;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_http_aliases(&self, http_aliases: &[&str]);

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_https_aliases(&self) -> Vec<GString>;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_https_aliases(&self, https_aliases: &[&str]);

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_idle_timeout(&self) -> u32;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_idle_timeout(&self, idle_timeout: u32);

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn get_property_local_address(&self) -> Option<Address>;

    fn get_property_max_conns(&self) -> i32;

    fn set_property_max_conns(&self, max_conns: i32);

    fn get_property_max_conns_per_host(&self) -> i32;

    fn set_property_max_conns_per_host(&self, max_conns_per_host: i32);

    //#[cfg(any(feature = "v2_42", feature = "dox"))]
    //fn get_property_proxy_resolver(&self) -> /*Ignored*/Option<gio::ProxyResolver>;

    //#[cfg(any(feature = "v2_42", feature = "dox"))]
    //fn set_property_proxy_resolver<P: IsA</*Ignored*/gio::ProxyResolver> + SetValueOptional>(&self, proxy_resolver: Option<&P>);

    fn get_property_proxy_uri(&self) -> Option<URI>;

    fn set_property_proxy_uri(&self, proxy_uri: Option<&URI>);

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_remove_feature_by_type(&self) -> glib::types::Type;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_remove_feature_by_type(&self, remove_feature_by_type: glib::types::Type);

    fn get_property_ssl_ca_file(&self) -> Option<GString>;

    fn set_property_ssl_ca_file(&self, ssl_ca_file: Option<&str>);

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_property_ssl_strict(&self) -> bool;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_property_ssl_strict(&self, ssl_strict: bool);

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_ssl_use_system_ca_file(&self) -> bool;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_ssl_use_system_ca_file(&self, ssl_use_system_ca_file: bool);

    fn get_property_timeout(&self) -> u32;

    fn set_property_timeout(&self, timeout: u32);

    //#[cfg(any(feature = "v2_38", feature = "dox"))]
    //fn get_property_tls_database(&self) -> /*Ignored*/Option<gio::TlsDatabase>;

    //#[cfg(any(feature = "v2_38", feature = "dox"))]
    //fn set_property_tls_database<P: IsA</*Ignored*/gio::TlsDatabase> + SetValueOptional>(&self, tls_database: Option<&P>);

    //#[cfg(any(feature = "v2_48", feature = "dox"))]
    //fn get_property_tls_interaction(&self) -> /*Ignored*/Option<gio::TlsInteraction>;

    //#[cfg(any(feature = "v2_48", feature = "dox"))]
    //fn set_property_tls_interaction<P: IsA</*Ignored*/gio::TlsInteraction> + SetValueOptional>(&self, tls_interaction: Option<&P>);

    fn get_property_use_ntlm(&self) -> bool;

    fn set_property_use_ntlm(&self, use_ntlm: bool);

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_use_thread_context(&self) -> bool;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_use_thread_context(&self, use_thread_context: bool);

    fn get_property_user_agent(&self) -> Option<GString>;

    fn set_property_user_agent(&self, user_agent: Option<&str>);

    fn connect_authenticate<F: Fn(&Self, &Message, &Auth, bool) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v2_30", feature = "dox"))]
    //fn connect_connection_created<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_request_queued<F: Fn(&Self, &Message) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg_attr(feature = "v2_50", deprecated)]
    //fn connect_request_started<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_request_unqueued<F: Fn(&Self, &Message) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v2_30", feature = "dox"))]
    //fn connect_tunneling<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_accept_language_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_accept_language_auto_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_add_feature_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_add_feature_by_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_http_aliases_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_https_aliases_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_idle_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_max_conns_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_max_conns_per_host_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn connect_property_proxy_resolver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_proxy_uri_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_remove_feature_by_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_ssl_ca_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_ssl_strict_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_ssl_use_system_ca_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_tls_database_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_48", feature = "dox"))]
    fn connect_property_tls_interaction_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_use_ntlm_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_use_thread_context_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_user_agent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Session>> SessionExt for O {
    fn abort(&self) {
        unsafe {
            soup_sys::soup_session_abort(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn add_feature<P: IsA<SessionFeature>>(&self, feature: &P) {
        unsafe {
            soup_sys::soup_session_add_feature(self.as_ref().to_glib_none().0, feature.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn add_feature_by_type(&self, feature_type: glib::types::Type) {
        unsafe {
            soup_sys::soup_session_add_feature_by_type(self.as_ref().to_glib_none().0, feature_type.to_glib());
        }
    }

    fn cancel_message<P: IsA<Message>>(&self, msg: &P, status_code: u32) {
        unsafe {
            soup_sys::soup_session_cancel_message(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0, status_code);
        }
    }

    //#[cfg(any(feature = "v2_62", feature = "dox"))]
    //fn connect_async<P: IsA<gio::Cancellable>, Q: FnOnce(Result<gio::IOStream, glib::Error>) + Send + 'static, R: FnOnce(Result<gio::IOStream, glib::Error>) + Send + 'static>(&self, uri: &mut URI, cancellable: Option<&P>, progress_callback: Q, callback: R) {
    //    unsafe { TODO: call soup_sys:soup_session_connect_async() }
    //}

    //
    //#[cfg(any(feature = "v2_62", feature = "dox"))]
    //fn connect_async_future<Q: FnOnce(Result<gio::IOStream, glib::Error>) + Send + 'static>(&self, uri: &mut URI, progress_callback: Q) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::IOStream, glib::Error>> + 'static>> {

        //let uri = uri.clone();
        //let progress_callback = progress_callback.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
        //    let cancellable = gio::Cancellable::new();
        //    obj.connect_async(
        //        &uri,
        //        Some(&cancellable),
        //        progress_callback.as_ref().map(::std::borrow::Borrow::borrow),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );

        //    cancellable
        //}))
    //}

    fn get_async_context(&self) -> Option<glib::MainContext> {
        unsafe {
            from_glib_none(soup_sys::soup_session_get_async_context(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    fn get_feature(&self, feature_type: glib::types::Type) -> Option<SessionFeature> {
        unsafe {
            from_glib_none(soup_sys::soup_session_get_feature(self.as_ref().to_glib_none().0, feature_type.to_glib()))
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    fn get_feature_for_message<P: IsA<Message>>(&self, feature_type: glib::types::Type, msg: &P) -> Option<SessionFeature> {
        unsafe {
            from_glib_none(soup_sys::soup_session_get_feature_for_message(self.as_ref().to_glib_none().0, feature_type.to_glib(), msg.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    fn get_features(&self, feature_type: glib::types::Type) -> Vec<SessionFeature> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(soup_sys::soup_session_get_features(self.as_ref().to_glib_none().0, feature_type.to_glib()))
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn has_feature(&self, feature_type: glib::types::Type) -> bool {
        unsafe {
            from_glib(soup_sys::soup_session_has_feature(self.as_ref().to_glib_none().0, feature_type.to_glib()))
        }
    }

    fn pause_message<P: IsA<Message>>(&self, msg: &P) {
        unsafe {
            soup_sys::soup_session_pause_message(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn prefetch_dns<P: IsA<gio::Cancellable>>(&self, hostname: &str, cancellable: Option<&P>, callback: Option<Box_<dyn FnOnce(&Address, u32) + 'static>>) {
        let callback_data: Box_<Option<Box_<dyn FnOnce(&Address, u32) + 'static>>> = Box_::new(callback);
        unsafe extern "C" fn callback_func<P: IsA<gio::Cancellable>>(addr: *mut soup_sys::SoupAddress, status: libc::c_uint, user_data: glib_sys::gpointer) {
            let addr = from_glib_borrow(addr);
            let callback: Box_<Option<Box_<dyn FnOnce(&Address, u32) + 'static>>> = Box_::from_raw(user_data as *mut _);
            let callback = (*callback).expect("cannot get closure...");
            callback(&addr, status)
        }
        let callback = if callback_data.is_some() { Some(callback_func::<P> as _) } else { None };
        let super_callback0: Box_<Option<Box_<dyn FnOnce(&Address, u32) + 'static>>> = callback_data;
        unsafe {
            soup_sys::soup_session_prefetch_dns(self.as_ref().to_glib_none().0, hostname.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, callback, Box_::into_raw(super_callback0) as *mut _);
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn prepare_for_uri(&self, uri: &mut URI) {
        unsafe {
            soup_sys::soup_session_prepare_for_uri(self.as_ref().to_glib_none().0, uri.to_glib_none_mut().0);
        }
    }

    fn queue_message<P: IsA<Message>>(&self, msg: &P, callback: Option<Box_<dyn FnOnce(&Session, &Message) + 'static>>) {
        let callback_data: Box_<Option<Box_<dyn FnOnce(&Session, &Message) + 'static>>> = Box_::new(callback);
        unsafe extern "C" fn callback_func<P: IsA<Message>>(session: *mut soup_sys::SoupSession, msg: *mut soup_sys::SoupMessage, user_data: glib_sys::gpointer) {
            let session = from_glib_borrow(session);
            let msg = from_glib_borrow(msg);
            let callback: Box_<Option<Box_<dyn FnOnce(&Session, &Message) + 'static>>> = Box_::from_raw(user_data as *mut _);
            let callback = (*callback).expect("cannot get closure...");
            callback(&session, &msg)
        }
        let callback = if callback_data.is_some() { Some(callback_func::<P> as _) } else { None };
        let super_callback0: Box_<Option<Box_<dyn FnOnce(&Session, &Message) + 'static>>> = callback_data;
        unsafe {
            soup_sys::soup_session_queue_message(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_full(), callback, Box_::into_raw(super_callback0) as *mut _);
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn redirect_message<P: IsA<Message>>(&self, msg: &P) -> bool {
        unsafe {
            from_glib(soup_sys::soup_session_redirect_message(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn remove_feature<P: IsA<SessionFeature>>(&self, feature: &P) {
        unsafe {
            soup_sys::soup_session_remove_feature(self.as_ref().to_glib_none().0, feature.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn remove_feature_by_type(&self, feature_type: glib::types::Type) {
        unsafe {
            soup_sys::soup_session_remove_feature_by_type(self.as_ref().to_glib_none().0, feature_type.to_glib());
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request(&self, uri_string: &str) -> Result<Request, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = soup_sys::soup_session_request(self.as_ref().to_glib_none().0, uri_string.to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request_http(&self, method: &str, uri_string: &str) -> Result<RequestHTTP, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = soup_sys::soup_session_request_http(self.as_ref().to_glib_none().0, method.to_glib_none().0, uri_string.to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request_http_uri(&self, method: &str, uri: &mut URI) -> Result<RequestHTTP, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = soup_sys::soup_session_request_http_uri(self.as_ref().to_glib_none().0, method.to_glib_none().0, uri.to_glib_none_mut().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn request_uri(&self, uri: &mut URI) -> Result<Request, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = soup_sys::soup_session_request_uri(self.as_ref().to_glib_none().0, uri.to_glib_none_mut().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    fn requeue_message<P: IsA<Message>>(&self, msg: &P) {
        unsafe {
            soup_sys::soup_session_requeue_message(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn send<P: IsA<Message>, Q: IsA<gio::Cancellable>>(&self, msg: &P, cancellable: Option<&Q>) -> Result<gio::InputStream, glib::Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = soup_sys::soup_session_send(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn send_async<P: IsA<Message>, Q: IsA<gio::Cancellable>, R: FnOnce(Result<gio::InputStream, glib::Error>) + Send + 'static>(&self, msg: &P, cancellable: Option<&Q>, callback: R) {
        let user_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn send_async_trampoline<R: FnOnce(Result<gio::InputStream, glib::Error>) + Send + 'static>(_source_object: *mut gobject_sys::GObject, res: *mut gio_sys::GAsyncResult, user_data: glib_sys::gpointer) {
            let mut error = ptr::null_mut();
            let ret = soup_sys::soup_session_send_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = send_async_trampoline::<R>;
        unsafe {
            soup_sys::soup_session_send_async(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn send_async_future<P: IsA<Message> + Clone + 'static>(&self, msg: &P) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::InputStream, glib::Error>> + 'static>> {

        let msg = msg.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, send| {
            let cancellable = gio::Cancellable::new();
            obj.send_async(
                &msg,
                Some(&cancellable),
                move |res| {
                    send.resolve(res);
                },
            );

            cancellable
        }))
    }

    fn send_message<P: IsA<Message>>(&self, msg: &P) -> u32 {
        unsafe {
            soup_sys::soup_session_send_message(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    fn steal_connection<P: IsA<Message>>(&self, msg: &P) -> Option<gio::IOStream> {
        unsafe {
            from_glib_full(soup_sys::soup_session_steal_connection(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0))
        }
    }

    fn unpause_message<P: IsA<Message>>(&self, msg: &P) {
        unsafe {
            soup_sys::soup_session_unpause_message(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v2_50", feature = "dox"))]
    //fn websocket_connect_async<P: IsA<Message>, Q: IsA<gio::Cancellable>, R: FnOnce(Result</*Ignored*/WebsocketConnection, glib::Error>) + Send + 'static>(&self, msg: &P, origin: Option<&str>, protocols: &[&str], cancellable: Option<&Q>, callback: R) {
    //    unsafe { TODO: call soup_sys:soup_session_websocket_connect_async() }
    //}

    //
    //#[cfg(any(feature = "v2_50", feature = "dox"))]
    //fn websocket_connect_async_future<P: IsA<Message> + Clone + 'static>(&self, msg: &P, origin: Option<&str>, protocols: &[&str]) -> Pin<Box_<dyn std::future::Future<Output = Result</*Ignored*/WebsocketConnection, glib::Error>> + 'static>> {

        //let msg = msg.clone();
        //let origin = origin.map(ToOwned::to_owned);
        //let protocols = protocols.map(ToOwned::to_owned);
        //Box_::pin(gio::GioFuture::new(self, move |obj, send| {
        //    let cancellable = gio::Cancellable::new();
        //    obj.websocket_connect_async(
        //        &msg,
        //        origin.as_ref().map(::std::borrow::Borrow::borrow),
        //        protocols.as_ref().map(::std::borrow::Borrow::borrow),
        //        Some(&cancellable),
        //        move |res| {
        //            send.resolve(res);
        //        },
        //    );

        //    cancellable
        //}))
    //}

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn would_redirect<P: IsA<Message>>(&self, msg: &P) -> bool {
        unsafe {
            from_glib(soup_sys::soup_session_would_redirect(self.as_ref().to_glib_none().0, msg.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_property_accept_language(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"accept-language\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `accept-language` getter")
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_property_accept_language(&self, accept_language: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"accept-language\0".as_ptr() as *const _, Value::from(accept_language).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_property_accept_language_auto(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"accept-language-auto\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `accept-language-auto` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_property_accept_language_auto(&self, accept_language_auto: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"accept-language-auto\0".as_ptr() as *const _, Value::from(&accept_language_auto).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_add_feature(&self) -> Option<SessionFeature> {
        unsafe {
            let mut value = Value::from_type(<SessionFeature as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"add-feature\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `add-feature` getter")
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_add_feature<P: IsA<SessionFeature> + SetValueOptional>(&self, add_feature: Option<&P>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"add-feature\0".as_ptr() as *const _, Value::from(add_feature).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_add_feature_by_type(&self) -> glib::types::Type {
        unsafe {
            let mut value = Value::from_type(<glib::types::Type as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"add-feature-by-type\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `add-feature-by-type` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_add_feature_by_type(&self, add_feature_by_type: glib::types::Type) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"add-feature-by-type\0".as_ptr() as *const _, Value::from(&add_feature_by_type).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_http_aliases(&self) -> Vec<GString> {
        unsafe {
            let mut value = Value::from_type(<Vec<GString> as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"http-aliases\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `http-aliases` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_http_aliases(&self, http_aliases: &[&str]) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"http-aliases\0".as_ptr() as *const _, Value::from(http_aliases).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_https_aliases(&self) -> Vec<GString> {
        unsafe {
            let mut value = Value::from_type(<Vec<GString> as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"https-aliases\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `https-aliases` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_https_aliases(&self, https_aliases: &[&str]) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"https-aliases\0".as_ptr() as *const _, Value::from(https_aliases).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_idle_timeout(&self) -> u32 {
        unsafe {
            let mut value = Value::from_type(<u32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"idle-timeout\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `idle-timeout` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_idle_timeout(&self, idle_timeout: u32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"idle-timeout\0".as_ptr() as *const _, Value::from(&idle_timeout).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn get_property_local_address(&self) -> Option<Address> {
        unsafe {
            let mut value = Value::from_type(<Address as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"local-address\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `local-address` getter")
        }
    }

    fn get_property_max_conns(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"max-conns\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `max-conns` getter").unwrap()
        }
    }

    fn set_property_max_conns(&self, max_conns: i32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"max-conns\0".as_ptr() as *const _, Value::from(&max_conns).to_glib_none().0);
        }
    }

    fn get_property_max_conns_per_host(&self) -> i32 {
        unsafe {
            let mut value = Value::from_type(<i32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"max-conns-per-host\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `max-conns-per-host` getter").unwrap()
        }
    }

    fn set_property_max_conns_per_host(&self, max_conns_per_host: i32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"max-conns-per-host\0".as_ptr() as *const _, Value::from(&max_conns_per_host).to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v2_42", feature = "dox"))]
    //fn get_property_proxy_resolver(&self) -> /*Ignored*/Option<gio::ProxyResolver> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"proxy-resolver\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `proxy-resolver` getter")
    //    }
    //}

    //#[cfg(any(feature = "v2_42", feature = "dox"))]
    //fn set_property_proxy_resolver<P: IsA</*Ignored*/gio::ProxyResolver> + SetValueOptional>(&self, proxy_resolver: Option<&P>) {
    //    unsafe {
    //        gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"proxy-resolver\0".as_ptr() as *const _, Value::from(proxy_resolver).to_glib_none().0);
    //    }
    //}

    fn get_property_proxy_uri(&self) -> Option<URI> {
        unsafe {
            let mut value = Value::from_type(<URI as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"proxy-uri\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `proxy-uri` getter")
        }
    }

    fn set_property_proxy_uri(&self, proxy_uri: Option<&URI>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"proxy-uri\0".as_ptr() as *const _, Value::from(proxy_uri).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn get_property_remove_feature_by_type(&self) -> glib::types::Type {
        unsafe {
            let mut value = Value::from_type(<glib::types::Type as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"remove-feature-by-type\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `remove-feature-by-type` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn set_property_remove_feature_by_type(&self, remove_feature_by_type: glib::types::Type) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"remove-feature-by-type\0".as_ptr() as *const _, Value::from(&remove_feature_by_type).to_glib_none().0);
        }
    }

    fn get_property_ssl_ca_file(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"ssl-ca-file\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `ssl-ca-file` getter")
        }
    }

    fn set_property_ssl_ca_file(&self, ssl_ca_file: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"ssl-ca-file\0".as_ptr() as *const _, Value::from(ssl_ca_file).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_property_ssl_strict(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"ssl-strict\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `ssl-strict` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_property_ssl_strict(&self, ssl_strict: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"ssl-strict\0".as_ptr() as *const _, Value::from(&ssl_strict).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_ssl_use_system_ca_file(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"ssl-use-system-ca-file\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `ssl-use-system-ca-file` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_ssl_use_system_ca_file(&self, ssl_use_system_ca_file: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"ssl-use-system-ca-file\0".as_ptr() as *const _, Value::from(&ssl_use_system_ca_file).to_glib_none().0);
        }
    }

    fn get_property_timeout(&self) -> u32 {
        unsafe {
            let mut value = Value::from_type(<u32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"timeout\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `timeout` getter").unwrap()
        }
    }

    fn set_property_timeout(&self, timeout: u32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"timeout\0".as_ptr() as *const _, Value::from(&timeout).to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v2_38", feature = "dox"))]
    //fn get_property_tls_database(&self) -> /*Ignored*/Option<gio::TlsDatabase> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-database\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `tls-database` getter")
    //    }
    //}

    //#[cfg(any(feature = "v2_38", feature = "dox"))]
    //fn set_property_tls_database<P: IsA</*Ignored*/gio::TlsDatabase> + SetValueOptional>(&self, tls_database: Option<&P>) {
    //    unsafe {
    //        gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-database\0".as_ptr() as *const _, Value::from(tls_database).to_glib_none().0);
    //    }
    //}

    //#[cfg(any(feature = "v2_48", feature = "dox"))]
    //fn get_property_tls_interaction(&self) -> /*Ignored*/Option<gio::TlsInteraction> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-interaction\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `tls-interaction` getter")
    //    }
    //}

    //#[cfg(any(feature = "v2_48", feature = "dox"))]
    //fn set_property_tls_interaction<P: IsA</*Ignored*/gio::TlsInteraction> + SetValueOptional>(&self, tls_interaction: Option<&P>) {
    //    unsafe {
    //        gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-interaction\0".as_ptr() as *const _, Value::from(tls_interaction).to_glib_none().0);
    //    }
    //}

    fn get_property_use_ntlm(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"use-ntlm\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `use-ntlm` getter").unwrap()
        }
    }

    fn set_property_use_ntlm(&self, use_ntlm: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"use-ntlm\0".as_ptr() as *const _, Value::from(&use_ntlm).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn get_property_use_thread_context(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"use-thread-context\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `use-thread-context` getter").unwrap()
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_property_use_thread_context(&self, use_thread_context: bool) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"use-thread-context\0".as_ptr() as *const _, Value::from(&use_thread_context).to_glib_none().0);
        }
    }

    fn get_property_user_agent(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"user-agent\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `user-agent` getter")
        }
    }

    fn set_property_user_agent(&self, user_agent: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"user-agent\0".as_ptr() as *const _, Value::from(user_agent).to_glib_none().0);
        }
    }

    fn connect_authenticate<F: Fn(&Self, &Message, &Auth, bool) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn authenticate_trampoline<P, F: Fn(&P, &Message, &Auth, bool) + 'static>(this: *mut soup_sys::SoupSession, msg: *mut soup_sys::SoupMessage, auth: *mut soup_sys::SoupAuth, retrying: glib_sys::gboolean, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast(), &from_glib_borrow(msg), &from_glib_borrow(auth), from_glib(retrying))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"authenticate\0".as_ptr() as *const _,
                Some(transmute(authenticate_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v2_30", feature = "dox"))]
    //fn connect_connection_created<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored connection: GObject.Object
    //}

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_request_queued<F: Fn(&Self, &Message) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn request_queued_trampoline<P, F: Fn(&P, &Message) + 'static>(this: *mut soup_sys::SoupSession, msg: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast(), &from_glib_borrow(msg))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"request-queued\0".as_ptr() as *const _,
                Some(transmute(request_queued_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    //fn connect_request_started<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored socket: Soup.Socket
    //}

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_request_unqueued<F: Fn(&Self, &Message) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn request_unqueued_trampoline<P, F: Fn(&P, &Message) + 'static>(this: *mut soup_sys::SoupSession, msg: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast(), &from_glib_borrow(msg))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"request-unqueued\0".as_ptr() as *const _,
                Some(transmute(request_unqueued_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v2_30", feature = "dox"))]
    //fn connect_tunneling<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored connection: GObject.Object
    //}

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_accept_language_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_accept_language_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::accept-language\0".as_ptr() as *const _,
                Some(transmute(notify_accept_language_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_accept_language_auto_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_accept_language_auto_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::accept-language-auto\0".as_ptr() as *const _,
                Some(transmute(notify_accept_language_auto_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_add_feature_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_add_feature_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::add-feature\0".as_ptr() as *const _,
                Some(transmute(notify_add_feature_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_add_feature_by_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_add_feature_by_type_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::add-feature-by-type\0".as_ptr() as *const _,
                Some(transmute(notify_add_feature_by_type_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_http_aliases_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_http_aliases_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::http-aliases\0".as_ptr() as *const _,
                Some(transmute(notify_http_aliases_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_https_aliases_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_https_aliases_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::https-aliases\0".as_ptr() as *const _,
                Some(transmute(notify_https_aliases_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_idle_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_idle_timeout_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::idle-timeout\0".as_ptr() as *const _,
                Some(transmute(notify_idle_timeout_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_max_conns_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_max_conns_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::max-conns\0".as_ptr() as *const _,
                Some(transmute(notify_max_conns_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_max_conns_per_host_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_max_conns_per_host_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::max-conns-per-host\0".as_ptr() as *const _,
                Some(transmute(notify_max_conns_per_host_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn connect_property_proxy_resolver_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_resolver_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::proxy-resolver\0".as_ptr() as *const _,
                Some(transmute(notify_proxy_resolver_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_proxy_uri_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_uri_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::proxy-uri\0".as_ptr() as *const _,
                Some(transmute(notify_proxy_uri_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_24", feature = "dox"))]
    fn connect_property_remove_feature_by_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_remove_feature_by_type_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::remove-feature-by-type\0".as_ptr() as *const _,
                Some(transmute(notify_remove_feature_by_type_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_ssl_ca_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ssl_ca_file_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::ssl-ca-file\0".as_ptr() as *const _,
                Some(transmute(notify_ssl_ca_file_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_ssl_strict_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ssl_strict_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::ssl-strict\0".as_ptr() as *const _,
                Some(transmute(notify_ssl_strict_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_ssl_use_system_ca_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ssl_use_system_ca_file_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::ssl-use-system-ca-file\0".as_ptr() as *const _,
                Some(transmute(notify_ssl_use_system_ca_file_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_timeout_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::timeout\0".as_ptr() as *const _,
                Some(transmute(notify_timeout_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_tls_database_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tls_database_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tls-database\0".as_ptr() as *const _,
                Some(transmute(notify_tls_database_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_48", feature = "dox"))]
    fn connect_property_tls_interaction_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tls_interaction_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tls-interaction\0".as_ptr() as *const _,
                Some(transmute(notify_tls_interaction_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_use_ntlm_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_use_ntlm_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::use-ntlm\0".as_ptr() as *const _,
                Some(transmute(notify_use_ntlm_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn connect_property_use_thread_context_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_use_thread_context_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::use-thread-context\0".as_ptr() as *const _,
                Some(transmute(notify_use_thread_context_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_user_agent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_user_agent_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupSession, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Session>
        {
            let f: &F = &*(f as *const F);
            f(&Session::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::user-agent\0".as_ptr() as *const _,
                Some(transmute(notify_user_agent_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Session {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Session")
    }
}
