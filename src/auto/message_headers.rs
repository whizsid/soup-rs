// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::translate::*;
use glib::GString;
use gobject_sys;
use soup_sys;
#[cfg(any(feature = "v2_26", feature = "dox"))]
use std::mem;
use Encoding;
use Expectation;
use MessageHeadersType;

glib_wrapper! {
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MessageHeaders(Boxed<soup_sys::SoupMessageHeaders>);

    match fn {
        copy => |ptr| gobject_sys::g_boxed_copy(soup_sys::soup_message_headers_get_type(), ptr as *mut _) as *mut soup_sys::SoupMessageHeaders,
        free => |ptr| gobject_sys::g_boxed_free(soup_sys::soup_message_headers_get_type(), ptr as *mut _),
        get_type => || soup_sys::soup_message_headers_get_type(),
    }
}

impl MessageHeaders {
    pub fn new(type_: MessageHeadersType) -> MessageHeaders {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(soup_sys::soup_message_headers_new(type_.to_glib()))
        }
    }

    pub fn append(&mut self, name: &str, value: &str) {
        unsafe {
            soup_sys::soup_message_headers_append(self.to_glib_none_mut().0, name.to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_36", feature = "dox"))]
    pub fn clean_connection_headers(&mut self) {
        unsafe {
            soup_sys::soup_message_headers_clean_connection_headers(self.to_glib_none_mut().0);
        }
    }

    pub fn clear(&mut self) {
        unsafe {
            soup_sys::soup_message_headers_clear(self.to_glib_none_mut().0);
        }
    }

    pub fn foreach<P: FnMut(&str, &str)>(&mut self, func: P) {
        let func_data: P = func;
        unsafe extern "C" fn func_func<P: FnMut(&str, &str)>(name: *const libc::c_char, value: *const libc::c_char, user_data: glib_sys::gpointer) {
            let name: GString = from_glib_borrow(name);
            let value: GString = from_glib_borrow(value);
            let callback: *mut P = user_data as *const _ as usize as *mut P;
            (*callback)(name.as_str(), value.as_str());
        }
        let func = Some(func_func::<P> as _);
        let super_callback0: &P = &func_data;
        unsafe {
            soup_sys::soup_message_headers_foreach(self.to_glib_none_mut().0, func, super_callback0 as *const _ as usize as *mut _);
        }
    }

    //#[cfg(any(feature = "v2_26", feature = "dox"))]
    //pub fn free_ranges(&mut self, ranges: /*Ignored*/&mut Range) {
    //    unsafe { TODO: call soup_sys:soup_message_headers_free_ranges() }
    //}

    pub fn get(&mut self, name: &str) -> Option<GString> {
        unsafe {
            from_glib_none(soup_sys::soup_message_headers_get(self.to_glib_none_mut().0, name.to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v2_26", feature = "dox"))]
    //pub fn get_content_disposition(&mut self, params: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Option<GString> {
    //    unsafe { TODO: call soup_sys:soup_message_headers_get_content_disposition() }
    //}

    pub fn get_content_length(&mut self) -> i64 {
        unsafe {
            soup_sys::soup_message_headers_get_content_length(self.to_glib_none_mut().0)
        }
    }

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    pub fn get_content_range(&mut self) -> Option<(i64, i64, i64)> {
        unsafe {
            let mut start = mem::MaybeUninit::uninit();
            let mut end = mem::MaybeUninit::uninit();
            let mut total_length = mem::MaybeUninit::uninit();
            let ret = from_glib(soup_sys::soup_message_headers_get_content_range(self.to_glib_none_mut().0, start.as_mut_ptr(), end.as_mut_ptr(), total_length.as_mut_ptr()));
            let start = start.assume_init();
            let end = end.assume_init();
            let total_length = total_length.assume_init();
            if ret { Some((start, end, total_length)) } else { None }
        }
    }

    //#[cfg(any(feature = "v2_26", feature = "dox"))]
    //pub fn get_content_type(&mut self, params: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) -> Option<GString> {
    //    unsafe { TODO: call soup_sys:soup_message_headers_get_content_type() }
    //}

    pub fn get_encoding(&mut self) -> Encoding {
        unsafe {
            from_glib(soup_sys::soup_message_headers_get_encoding(self.to_glib_none_mut().0))
        }
    }

    pub fn get_expectations(&mut self) -> Expectation {
        unsafe {
            from_glib(soup_sys::soup_message_headers_get_expectations(self.to_glib_none_mut().0))
        }
    }

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn get_headers_type(&mut self) -> MessageHeadersType {
        unsafe {
            from_glib(soup_sys::soup_message_headers_get_headers_type(self.to_glib_none_mut().0))
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    pub fn get_list(&mut self, name: &str) -> Option<GString> {
        unsafe {
            from_glib_none(soup_sys::soup_message_headers_get_list(self.to_glib_none_mut().0, name.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    pub fn get_one(&mut self, name: &str) -> Option<GString> {
        unsafe {
            from_glib_none(soup_sys::soup_message_headers_get_one(self.to_glib_none_mut().0, name.to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v2_26", feature = "dox"))]
    //pub fn get_ranges(&mut self, total_length: i64, ranges: /*Ignored*/Vec<Range>) -> Option<i32> {
    //    unsafe { TODO: call soup_sys:soup_message_headers_get_ranges() }
    //}

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn header_contains(&mut self, name: &str, token: &str) -> bool {
        unsafe {
            from_glib(soup_sys::soup_message_headers_header_contains(self.to_glib_none_mut().0, name.to_glib_none().0, token.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    pub fn header_equals(&mut self, name: &str, value: &str) -> bool {
        unsafe {
            from_glib(soup_sys::soup_message_headers_header_equals(self.to_glib_none_mut().0, name.to_glib_none().0, value.to_glib_none().0))
        }
    }

    pub fn remove(&mut self, name: &str) {
        unsafe {
            soup_sys::soup_message_headers_remove(self.to_glib_none_mut().0, name.to_glib_none().0);
        }
    }

    pub fn replace(&mut self, name: &str, value: &str) {
        unsafe {
            soup_sys::soup_message_headers_replace(self.to_glib_none_mut().0, name.to_glib_none().0, value.to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v2_26", feature = "dox"))]
    //pub fn set_content_disposition(&mut self, disposition: &str, params: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) {
    //    unsafe { TODO: call soup_sys:soup_message_headers_set_content_disposition() }
    //}

    pub fn set_content_length(&mut self, content_length: i64) {
        unsafe {
            soup_sys::soup_message_headers_set_content_length(self.to_glib_none_mut().0, content_length);
        }
    }

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    pub fn set_content_range(&mut self, start: i64, end: i64, total_length: i64) {
        unsafe {
            soup_sys::soup_message_headers_set_content_range(self.to_glib_none_mut().0, start, end, total_length);
        }
    }

    //#[cfg(any(feature = "v2_26", feature = "dox"))]
    //pub fn set_content_type(&mut self, content_type: &str, params: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) {
    //    unsafe { TODO: call soup_sys:soup_message_headers_set_content_type() }
    //}

    pub fn set_encoding(&mut self, encoding: Encoding) {
        unsafe {
            soup_sys::soup_message_headers_set_encoding(self.to_glib_none_mut().0, encoding.to_glib());
        }
    }

    pub fn set_expectations(&mut self, expectations: Expectation) {
        unsafe {
            soup_sys::soup_message_headers_set_expectations(self.to_glib_none_mut().0, expectations.to_glib());
        }
    }

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    pub fn set_range(&mut self, start: i64, end: i64) {
        unsafe {
            soup_sys::soup_message_headers_set_range(self.to_glib_none_mut().0, start, end);
        }
    }

    //#[cfg(any(feature = "v2_26", feature = "dox"))]
    //pub fn set_ranges(&mut self, ranges: /*Ignored*/&mut Range, length: i32) {
    //    unsafe { TODO: call soup_sys:soup_message_headers_set_ranges() }
    //}
}
