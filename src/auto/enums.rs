// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use soup_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum AddressFamily {
    Invalid,
    Ipv4,
    Ipv6,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AddressFamily {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AddressFamily::{}", match *self {
            AddressFamily::Invalid => "Invalid",
            AddressFamily::Ipv4 => "Ipv4",
            AddressFamily::Ipv6 => "Ipv6",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for AddressFamily {
    type GlibType = soup_sys::SoupAddressFamily;

    fn to_glib(&self) -> soup_sys::SoupAddressFamily {
        match *self {
            AddressFamily::Invalid => soup_sys::SOUP_ADDRESS_FAMILY_INVALID,
            AddressFamily::Ipv4 => soup_sys::SOUP_ADDRESS_FAMILY_IPV4,
            AddressFamily::Ipv6 => soup_sys::SOUP_ADDRESS_FAMILY_IPV6,
            AddressFamily::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupAddressFamily> for AddressFamily {
    fn from_glib(value: soup_sys::SoupAddressFamily) -> Self {
        skip_assert_initialized!();
        match value {
            -1 => AddressFamily::Invalid,
            2 => AddressFamily::Ipv4,
            10 => AddressFamily::Ipv6,
            value => AddressFamily::__Unknown(value),
        }
    }
}

impl StaticType for AddressFamily {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_address_family_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for AddressFamily {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for AddressFamily {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for AddressFamily {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum CacheResponse {
    Fresh,
    NeedsValidation,
    Stale,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CacheResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CacheResponse::{}", match *self {
            CacheResponse::Fresh => "Fresh",
            CacheResponse::NeedsValidation => "NeedsValidation",
            CacheResponse::Stale => "Stale",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for CacheResponse {
    type GlibType = soup_sys::SoupCacheResponse;

    fn to_glib(&self) -> soup_sys::SoupCacheResponse {
        match *self {
            CacheResponse::Fresh => soup_sys::SOUP_CACHE_RESPONSE_FRESH,
            CacheResponse::NeedsValidation => soup_sys::SOUP_CACHE_RESPONSE_NEEDS_VALIDATION,
            CacheResponse::Stale => soup_sys::SOUP_CACHE_RESPONSE_STALE,
            CacheResponse::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupCacheResponse> for CacheResponse {
    fn from_glib(value: soup_sys::SoupCacheResponse) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CacheResponse::Fresh,
            1 => CacheResponse::NeedsValidation,
            2 => CacheResponse::Stale,
            value => CacheResponse::__Unknown(value),
        }
    }
}

impl StaticType for CacheResponse {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_cache_response_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for CacheResponse {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for CacheResponse {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for CacheResponse {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum CacheType {
    SingleUser,
    Shared,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl fmt::Display for CacheType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CacheType::{}", match *self {
            CacheType::SingleUser => "SingleUser",
            CacheType::Shared => "Shared",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for CacheType {
    type GlibType = soup_sys::SoupCacheType;

    fn to_glib(&self) -> soup_sys::SoupCacheType {
        match *self {
            CacheType::SingleUser => soup_sys::SOUP_CACHE_SINGLE_USER,
            CacheType::Shared => soup_sys::SOUP_CACHE_SHARED,
            CacheType::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupCacheType> for CacheType {
    fn from_glib(value: soup_sys::SoupCacheType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CacheType::SingleUser,
            1 => CacheType::Shared,
            value => CacheType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl StaticType for CacheType {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_cache_type_get_type()) }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl<'a> FromValueOptional<'a> for CacheType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl<'a> FromValue<'a> for CacheType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
impl SetValue for CacheType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum ConnectionState {
    New,
    Connecting,
    Idle,
    InUse,
    RemoteDisconnected,
    Disconnected,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ConnectionState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ConnectionState::{}", match *self {
            ConnectionState::New => "New",
            ConnectionState::Connecting => "Connecting",
            ConnectionState::Idle => "Idle",
            ConnectionState::InUse => "InUse",
            ConnectionState::RemoteDisconnected => "RemoteDisconnected",
            ConnectionState::Disconnected => "Disconnected",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for ConnectionState {
    type GlibType = soup_sys::SoupConnectionState;

    fn to_glib(&self) -> soup_sys::SoupConnectionState {
        match *self {
            ConnectionState::New => soup_sys::SOUP_CONNECTION_NEW,
            ConnectionState::Connecting => soup_sys::SOUP_CONNECTION_CONNECTING,
            ConnectionState::Idle => soup_sys::SOUP_CONNECTION_IDLE,
            ConnectionState::InUse => soup_sys::SOUP_CONNECTION_IN_USE,
            ConnectionState::RemoteDisconnected => soup_sys::SOUP_CONNECTION_REMOTE_DISCONNECTED,
            ConnectionState::Disconnected => soup_sys::SOUP_CONNECTION_DISCONNECTED,
            ConnectionState::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupConnectionState> for ConnectionState {
    fn from_glib(value: soup_sys::SoupConnectionState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => ConnectionState::New,
            1 => ConnectionState::Connecting,
            2 => ConnectionState::Idle,
            3 => ConnectionState::InUse,
            4 => ConnectionState::RemoteDisconnected,
            5 => ConnectionState::Disconnected,
            value => ConnectionState::__Unknown(value),
        }
    }
}

impl StaticType for ConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_connection_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for ConnectionState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for ConnectionState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for ConnectionState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum CookieJarAcceptPolicy {
    Always,
    Never,
    NoThirdParty,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
impl fmt::Display for CookieJarAcceptPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CookieJarAcceptPolicy::{}", match *self {
            CookieJarAcceptPolicy::Always => "Always",
            CookieJarAcceptPolicy::Never => "Never",
            CookieJarAcceptPolicy::NoThirdParty => "NoThirdParty",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for CookieJarAcceptPolicy {
    type GlibType = soup_sys::SoupCookieJarAcceptPolicy;

    fn to_glib(&self) -> soup_sys::SoupCookieJarAcceptPolicy {
        match *self {
            CookieJarAcceptPolicy::Always => soup_sys::SOUP_COOKIE_JAR_ACCEPT_ALWAYS,
            CookieJarAcceptPolicy::Never => soup_sys::SOUP_COOKIE_JAR_ACCEPT_NEVER,
            CookieJarAcceptPolicy::NoThirdParty => soup_sys::SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY,
            CookieJarAcceptPolicy::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupCookieJarAcceptPolicy> for CookieJarAcceptPolicy {
    fn from_glib(value: soup_sys::SoupCookieJarAcceptPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CookieJarAcceptPolicy::Always,
            1 => CookieJarAcceptPolicy::Never,
            2 => CookieJarAcceptPolicy::NoThirdParty,
            value => CookieJarAcceptPolicy::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
impl StaticType for CookieJarAcceptPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_cookie_jar_accept_policy_get_type()) }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
impl<'a> FromValueOptional<'a> for CookieJarAcceptPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
impl<'a> FromValue<'a> for CookieJarAcceptPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
impl SetValue for CookieJarAcceptPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum DateFormat {
    Http,
    Cookie,
    Rfc2822,
    Iso8601Compact,
    Iso8601Full,
    Iso8601Xmlrpc,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for DateFormat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "DateFormat::{}", match *self {
            DateFormat::Http => "Http",
            DateFormat::Cookie => "Cookie",
            DateFormat::Rfc2822 => "Rfc2822",
            DateFormat::Iso8601Compact => "Iso8601Compact",
            DateFormat::Iso8601Full => "Iso8601Full",
            DateFormat::Iso8601Xmlrpc => "Iso8601Xmlrpc",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for DateFormat {
    type GlibType = soup_sys::SoupDateFormat;

    fn to_glib(&self) -> soup_sys::SoupDateFormat {
        match *self {
            DateFormat::Http => soup_sys::SOUP_DATE_HTTP,
            DateFormat::Cookie => soup_sys::SOUP_DATE_COOKIE,
            DateFormat::Rfc2822 => soup_sys::SOUP_DATE_RFC2822,
            DateFormat::Iso8601Compact => soup_sys::SOUP_DATE_ISO8601_COMPACT,
            DateFormat::Iso8601Full => soup_sys::SOUP_DATE_ISO8601_FULL,
            DateFormat::Iso8601Xmlrpc => soup_sys::SOUP_DATE_ISO8601_XMLRPC,
            DateFormat::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupDateFormat> for DateFormat {
    fn from_glib(value: soup_sys::SoupDateFormat) -> Self {
        skip_assert_initialized!();
        match value {
            1 => DateFormat::Http,
            2 => DateFormat::Cookie,
            3 => DateFormat::Rfc2822,
            4 => DateFormat::Iso8601Compact,
            5 => DateFormat::Iso8601Full,
            6 => DateFormat::Iso8601Xmlrpc,
            value => DateFormat::__Unknown(value),
        }
    }
}

impl StaticType for DateFormat {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_date_format_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for DateFormat {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for DateFormat {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for DateFormat {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum Encoding {
    Unrecognized,
    None,
    ContentLength,
    Eof,
    Chunked,
    Byteranges,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Encoding {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Encoding::{}", match *self {
            Encoding::Unrecognized => "Unrecognized",
            Encoding::None => "None",
            Encoding::ContentLength => "ContentLength",
            Encoding::Eof => "Eof",
            Encoding::Chunked => "Chunked",
            Encoding::Byteranges => "Byteranges",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Encoding {
    type GlibType = soup_sys::SoupEncoding;

    fn to_glib(&self) -> soup_sys::SoupEncoding {
        match *self {
            Encoding::Unrecognized => soup_sys::SOUP_ENCODING_UNRECOGNIZED,
            Encoding::None => soup_sys::SOUP_ENCODING_NONE,
            Encoding::ContentLength => soup_sys::SOUP_ENCODING_CONTENT_LENGTH,
            Encoding::Eof => soup_sys::SOUP_ENCODING_EOF,
            Encoding::Chunked => soup_sys::SOUP_ENCODING_CHUNKED,
            Encoding::Byteranges => soup_sys::SOUP_ENCODING_BYTERANGES,
            Encoding::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupEncoding> for Encoding {
    fn from_glib(value: soup_sys::SoupEncoding) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Encoding::Unrecognized,
            1 => Encoding::None,
            2 => Encoding::ContentLength,
            3 => Encoding::Eof,
            4 => Encoding::Chunked,
            5 => Encoding::Byteranges,
            value => Encoding::__Unknown(value),
        }
    }
}

impl StaticType for Encoding {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_encoding_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Encoding {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Encoding {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Encoding {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum HTTPVersion {
    Http10,
    Http11,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for HTTPVersion {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "HTTPVersion::{}", match *self {
            HTTPVersion::Http10 => "Http10",
            HTTPVersion::Http11 => "Http11",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for HTTPVersion {
    type GlibType = soup_sys::SoupHTTPVersion;

    fn to_glib(&self) -> soup_sys::SoupHTTPVersion {
        match *self {
            HTTPVersion::Http10 => soup_sys::SOUP_HTTP_1_0,
            HTTPVersion::Http11 => soup_sys::SOUP_HTTP_1_1,
            HTTPVersion::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupHTTPVersion> for HTTPVersion {
    fn from_glib(value: soup_sys::SoupHTTPVersion) -> Self {
        skip_assert_initialized!();
        match value {
            0 => HTTPVersion::Http10,
            1 => HTTPVersion::Http11,
            value => HTTPVersion::__Unknown(value),
        }
    }
}

impl StaticType for HTTPVersion {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_http_version_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for HTTPVersion {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for HTTPVersion {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for HTTPVersion {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum KnownStatusCode {
    None,
    Cancelled,
    CantResolve,
    CantResolveProxy,
    CantConnect,
    CantConnectProxy,
    SslFailed,
    IoError,
    Malformed,
    TryAgain,
    TooManyRedirects,
    TlsFailed,
    Continue,
    SwitchingProtocols,
    Processing,
    Ok,
    Created,
    Accepted,
    NonAuthoritative,
    NoContent,
    ResetContent,
    PartialContent,
    MultiStatus,
    MultipleChoices,
    MovedPermanently,
    Found,
    SeeOther,
    NotModified,
    UseProxy,
    NotAppearingInThisProtocol,
    TemporaryRedirect,
    BadRequest,
    Unauthorized,
    PaymentRequired,
    Forbidden,
    NotFound,
    MethodNotAllowed,
    NotAcceptable,
    ProxyAuthenticationRequired,
    RequestTimeout,
    Conflict,
    Gone,
    LengthRequired,
    PreconditionFailed,
    RequestEntityTooLarge,
    RequestUriTooLong,
    UnsupportedMediaType,
    RequestedRangeNotSatisfiable,
    ExpectationFailed,
    UnprocessableEntity,
    Locked,
    FailedDependency,
    InternalServerError,
    NotImplemented,
    BadGateway,
    ServiceUnavailable,
    GatewayTimeout,
    HttpVersionNotSupported,
    InsufficientStorage,
    NotExtended,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for KnownStatusCode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "KnownStatusCode::{}", match *self {
            KnownStatusCode::None => "None",
            KnownStatusCode::Cancelled => "Cancelled",
            KnownStatusCode::CantResolve => "CantResolve",
            KnownStatusCode::CantResolveProxy => "CantResolveProxy",
            KnownStatusCode::CantConnect => "CantConnect",
            KnownStatusCode::CantConnectProxy => "CantConnectProxy",
            KnownStatusCode::SslFailed => "SslFailed",
            KnownStatusCode::IoError => "IoError",
            KnownStatusCode::Malformed => "Malformed",
            KnownStatusCode::TryAgain => "TryAgain",
            KnownStatusCode::TooManyRedirects => "TooManyRedirects",
            KnownStatusCode::TlsFailed => "TlsFailed",
            KnownStatusCode::Continue => "Continue",
            KnownStatusCode::SwitchingProtocols => "SwitchingProtocols",
            KnownStatusCode::Processing => "Processing",
            KnownStatusCode::Ok => "Ok",
            KnownStatusCode::Created => "Created",
            KnownStatusCode::Accepted => "Accepted",
            KnownStatusCode::NonAuthoritative => "NonAuthoritative",
            KnownStatusCode::NoContent => "NoContent",
            KnownStatusCode::ResetContent => "ResetContent",
            KnownStatusCode::PartialContent => "PartialContent",
            KnownStatusCode::MultiStatus => "MultiStatus",
            KnownStatusCode::MultipleChoices => "MultipleChoices",
            KnownStatusCode::MovedPermanently => "MovedPermanently",
            KnownStatusCode::Found => "Found",
            KnownStatusCode::SeeOther => "SeeOther",
            KnownStatusCode::NotModified => "NotModified",
            KnownStatusCode::UseProxy => "UseProxy",
            KnownStatusCode::NotAppearingInThisProtocol => "NotAppearingInThisProtocol",
            KnownStatusCode::TemporaryRedirect => "TemporaryRedirect",
            KnownStatusCode::BadRequest => "BadRequest",
            KnownStatusCode::Unauthorized => "Unauthorized",
            KnownStatusCode::PaymentRequired => "PaymentRequired",
            KnownStatusCode::Forbidden => "Forbidden",
            KnownStatusCode::NotFound => "NotFound",
            KnownStatusCode::MethodNotAllowed => "MethodNotAllowed",
            KnownStatusCode::NotAcceptable => "NotAcceptable",
            KnownStatusCode::ProxyAuthenticationRequired => "ProxyAuthenticationRequired",
            KnownStatusCode::RequestTimeout => "RequestTimeout",
            KnownStatusCode::Conflict => "Conflict",
            KnownStatusCode::Gone => "Gone",
            KnownStatusCode::LengthRequired => "LengthRequired",
            KnownStatusCode::PreconditionFailed => "PreconditionFailed",
            KnownStatusCode::RequestEntityTooLarge => "RequestEntityTooLarge",
            KnownStatusCode::RequestUriTooLong => "RequestUriTooLong",
            KnownStatusCode::UnsupportedMediaType => "UnsupportedMediaType",
            KnownStatusCode::RequestedRangeNotSatisfiable => "RequestedRangeNotSatisfiable",
            KnownStatusCode::ExpectationFailed => "ExpectationFailed",
            KnownStatusCode::UnprocessableEntity => "UnprocessableEntity",
            KnownStatusCode::Locked => "Locked",
            KnownStatusCode::FailedDependency => "FailedDependency",
            KnownStatusCode::InternalServerError => "InternalServerError",
            KnownStatusCode::NotImplemented => "NotImplemented",
            KnownStatusCode::BadGateway => "BadGateway",
            KnownStatusCode::ServiceUnavailable => "ServiceUnavailable",
            KnownStatusCode::GatewayTimeout => "GatewayTimeout",
            KnownStatusCode::HttpVersionNotSupported => "HttpVersionNotSupported",
            KnownStatusCode::InsufficientStorage => "InsufficientStorage",
            KnownStatusCode::NotExtended => "NotExtended",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for KnownStatusCode {
    type GlibType = soup_sys::SoupKnownStatusCode;

    fn to_glib(&self) -> soup_sys::SoupKnownStatusCode {
        match *self {
            KnownStatusCode::None => soup_sys::SOUP_KNOWN_STATUS_CODE_NONE,
            KnownStatusCode::Cancelled => soup_sys::SOUP_KNOWN_STATUS_CODE_CANCELLED,
            KnownStatusCode::CantResolve => soup_sys::SOUP_KNOWN_STATUS_CODE_CANT_RESOLVE,
            KnownStatusCode::CantResolveProxy => soup_sys::SOUP_KNOWN_STATUS_CODE_CANT_RESOLVE_PROXY,
            KnownStatusCode::CantConnect => soup_sys::SOUP_KNOWN_STATUS_CODE_CANT_CONNECT,
            KnownStatusCode::CantConnectProxy => soup_sys::SOUP_KNOWN_STATUS_CODE_CANT_CONNECT_PROXY,
            KnownStatusCode::SslFailed => soup_sys::SOUP_KNOWN_STATUS_CODE_SSL_FAILED,
            KnownStatusCode::IoError => soup_sys::SOUP_KNOWN_STATUS_CODE_IO_ERROR,
            KnownStatusCode::Malformed => soup_sys::SOUP_KNOWN_STATUS_CODE_MALFORMED,
            KnownStatusCode::TryAgain => soup_sys::SOUP_KNOWN_STATUS_CODE_TRY_AGAIN,
            KnownStatusCode::TooManyRedirects => soup_sys::SOUP_KNOWN_STATUS_CODE_TOO_MANY_REDIRECTS,
            KnownStatusCode::TlsFailed => soup_sys::SOUP_KNOWN_STATUS_CODE_TLS_FAILED,
            KnownStatusCode::Continue => soup_sys::SOUP_KNOWN_STATUS_CODE_CONTINUE,
            KnownStatusCode::SwitchingProtocols => soup_sys::SOUP_KNOWN_STATUS_CODE_SWITCHING_PROTOCOLS,
            KnownStatusCode::Processing => soup_sys::SOUP_KNOWN_STATUS_CODE_PROCESSING,
            KnownStatusCode::Ok => soup_sys::SOUP_KNOWN_STATUS_CODE_OK,
            KnownStatusCode::Created => soup_sys::SOUP_KNOWN_STATUS_CODE_CREATED,
            KnownStatusCode::Accepted => soup_sys::SOUP_KNOWN_STATUS_CODE_ACCEPTED,
            KnownStatusCode::NonAuthoritative => soup_sys::SOUP_KNOWN_STATUS_CODE_NON_AUTHORITATIVE,
            KnownStatusCode::NoContent => soup_sys::SOUP_KNOWN_STATUS_CODE_NO_CONTENT,
            KnownStatusCode::ResetContent => soup_sys::SOUP_KNOWN_STATUS_CODE_RESET_CONTENT,
            KnownStatusCode::PartialContent => soup_sys::SOUP_KNOWN_STATUS_CODE_PARTIAL_CONTENT,
            KnownStatusCode::MultiStatus => soup_sys::SOUP_KNOWN_STATUS_CODE_MULTI_STATUS,
            KnownStatusCode::MultipleChoices => soup_sys::SOUP_KNOWN_STATUS_CODE_MULTIPLE_CHOICES,
            KnownStatusCode::MovedPermanently => soup_sys::SOUP_KNOWN_STATUS_CODE_MOVED_PERMANENTLY,
            KnownStatusCode::Found => soup_sys::SOUP_KNOWN_STATUS_CODE_FOUND,
            KnownStatusCode::SeeOther => soup_sys::SOUP_KNOWN_STATUS_CODE_SEE_OTHER,
            KnownStatusCode::NotModified => soup_sys::SOUP_KNOWN_STATUS_CODE_NOT_MODIFIED,
            KnownStatusCode::UseProxy => soup_sys::SOUP_KNOWN_STATUS_CODE_USE_PROXY,
            KnownStatusCode::NotAppearingInThisProtocol => soup_sys::SOUP_KNOWN_STATUS_CODE_NOT_APPEARING_IN_THIS_PROTOCOL,
            KnownStatusCode::TemporaryRedirect => soup_sys::SOUP_KNOWN_STATUS_CODE_TEMPORARY_REDIRECT,
            KnownStatusCode::BadRequest => soup_sys::SOUP_KNOWN_STATUS_CODE_BAD_REQUEST,
            KnownStatusCode::Unauthorized => soup_sys::SOUP_KNOWN_STATUS_CODE_UNAUTHORIZED,
            KnownStatusCode::PaymentRequired => soup_sys::SOUP_KNOWN_STATUS_CODE_PAYMENT_REQUIRED,
            KnownStatusCode::Forbidden => soup_sys::SOUP_KNOWN_STATUS_CODE_FORBIDDEN,
            KnownStatusCode::NotFound => soup_sys::SOUP_KNOWN_STATUS_CODE_NOT_FOUND,
            KnownStatusCode::MethodNotAllowed => soup_sys::SOUP_KNOWN_STATUS_CODE_METHOD_NOT_ALLOWED,
            KnownStatusCode::NotAcceptable => soup_sys::SOUP_KNOWN_STATUS_CODE_NOT_ACCEPTABLE,
            KnownStatusCode::ProxyAuthenticationRequired => soup_sys::SOUP_KNOWN_STATUS_CODE_PROXY_AUTHENTICATION_REQUIRED,
            KnownStatusCode::RequestTimeout => soup_sys::SOUP_KNOWN_STATUS_CODE_REQUEST_TIMEOUT,
            KnownStatusCode::Conflict => soup_sys::SOUP_KNOWN_STATUS_CODE_CONFLICT,
            KnownStatusCode::Gone => soup_sys::SOUP_KNOWN_STATUS_CODE_GONE,
            KnownStatusCode::LengthRequired => soup_sys::SOUP_KNOWN_STATUS_CODE_LENGTH_REQUIRED,
            KnownStatusCode::PreconditionFailed => soup_sys::SOUP_KNOWN_STATUS_CODE_PRECONDITION_FAILED,
            KnownStatusCode::RequestEntityTooLarge => soup_sys::SOUP_KNOWN_STATUS_CODE_REQUEST_ENTITY_TOO_LARGE,
            KnownStatusCode::RequestUriTooLong => soup_sys::SOUP_KNOWN_STATUS_CODE_REQUEST_URI_TOO_LONG,
            KnownStatusCode::UnsupportedMediaType => soup_sys::SOUP_KNOWN_STATUS_CODE_UNSUPPORTED_MEDIA_TYPE,
            KnownStatusCode::RequestedRangeNotSatisfiable => soup_sys::SOUP_KNOWN_STATUS_CODE_REQUESTED_RANGE_NOT_SATISFIABLE,
            KnownStatusCode::ExpectationFailed => soup_sys::SOUP_KNOWN_STATUS_CODE_EXPECTATION_FAILED,
            KnownStatusCode::UnprocessableEntity => soup_sys::SOUP_KNOWN_STATUS_CODE_UNPROCESSABLE_ENTITY,
            KnownStatusCode::Locked => soup_sys::SOUP_KNOWN_STATUS_CODE_LOCKED,
            KnownStatusCode::FailedDependency => soup_sys::SOUP_KNOWN_STATUS_CODE_FAILED_DEPENDENCY,
            KnownStatusCode::InternalServerError => soup_sys::SOUP_KNOWN_STATUS_CODE_INTERNAL_SERVER_ERROR,
            KnownStatusCode::NotImplemented => soup_sys::SOUP_KNOWN_STATUS_CODE_NOT_IMPLEMENTED,
            KnownStatusCode::BadGateway => soup_sys::SOUP_KNOWN_STATUS_CODE_BAD_GATEWAY,
            KnownStatusCode::ServiceUnavailable => soup_sys::SOUP_KNOWN_STATUS_CODE_SERVICE_UNAVAILABLE,
            KnownStatusCode::GatewayTimeout => soup_sys::SOUP_KNOWN_STATUS_CODE_GATEWAY_TIMEOUT,
            KnownStatusCode::HttpVersionNotSupported => soup_sys::SOUP_KNOWN_STATUS_CODE_HTTP_VERSION_NOT_SUPPORTED,
            KnownStatusCode::InsufficientStorage => soup_sys::SOUP_KNOWN_STATUS_CODE_INSUFFICIENT_STORAGE,
            KnownStatusCode::NotExtended => soup_sys::SOUP_KNOWN_STATUS_CODE_NOT_EXTENDED,
            KnownStatusCode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupKnownStatusCode> for KnownStatusCode {
    fn from_glib(value: soup_sys::SoupKnownStatusCode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => KnownStatusCode::None,
            1 => KnownStatusCode::Cancelled,
            2 => KnownStatusCode::CantResolve,
            3 => KnownStatusCode::CantResolveProxy,
            4 => KnownStatusCode::CantConnect,
            5 => KnownStatusCode::CantConnectProxy,
            6 => KnownStatusCode::SslFailed,
            7 => KnownStatusCode::IoError,
            8 => KnownStatusCode::Malformed,
            9 => KnownStatusCode::TryAgain,
            10 => KnownStatusCode::TooManyRedirects,
            11 => KnownStatusCode::TlsFailed,
            100 => KnownStatusCode::Continue,
            101 => KnownStatusCode::SwitchingProtocols,
            102 => KnownStatusCode::Processing,
            200 => KnownStatusCode::Ok,
            201 => KnownStatusCode::Created,
            202 => KnownStatusCode::Accepted,
            203 => KnownStatusCode::NonAuthoritative,
            204 => KnownStatusCode::NoContent,
            205 => KnownStatusCode::ResetContent,
            206 => KnownStatusCode::PartialContent,
            207 => KnownStatusCode::MultiStatus,
            300 => KnownStatusCode::MultipleChoices,
            301 => KnownStatusCode::MovedPermanently,
            302 => KnownStatusCode::Found,
            303 => KnownStatusCode::SeeOther,
            304 => KnownStatusCode::NotModified,
            305 => KnownStatusCode::UseProxy,
            306 => KnownStatusCode::NotAppearingInThisProtocol,
            307 => KnownStatusCode::TemporaryRedirect,
            400 => KnownStatusCode::BadRequest,
            401 => KnownStatusCode::Unauthorized,
            402 => KnownStatusCode::PaymentRequired,
            403 => KnownStatusCode::Forbidden,
            404 => KnownStatusCode::NotFound,
            405 => KnownStatusCode::MethodNotAllowed,
            406 => KnownStatusCode::NotAcceptable,
            407 => KnownStatusCode::ProxyAuthenticationRequired,
            408 => KnownStatusCode::RequestTimeout,
            409 => KnownStatusCode::Conflict,
            410 => KnownStatusCode::Gone,
            411 => KnownStatusCode::LengthRequired,
            412 => KnownStatusCode::PreconditionFailed,
            413 => KnownStatusCode::RequestEntityTooLarge,
            414 => KnownStatusCode::RequestUriTooLong,
            415 => KnownStatusCode::UnsupportedMediaType,
            416 => KnownStatusCode::RequestedRangeNotSatisfiable,
            417 => KnownStatusCode::ExpectationFailed,
            422 => KnownStatusCode::UnprocessableEntity,
            423 => KnownStatusCode::Locked,
            424 => KnownStatusCode::FailedDependency,
            500 => KnownStatusCode::InternalServerError,
            501 => KnownStatusCode::NotImplemented,
            502 => KnownStatusCode::BadGateway,
            503 => KnownStatusCode::ServiceUnavailable,
            504 => KnownStatusCode::GatewayTimeout,
            505 => KnownStatusCode::HttpVersionNotSupported,
            507 => KnownStatusCode::InsufficientStorage,
            510 => KnownStatusCode::NotExtended,
            value => KnownStatusCode::__Unknown(value),
        }
    }
}

impl StaticType for KnownStatusCode {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_known_status_code_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for KnownStatusCode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for KnownStatusCode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for KnownStatusCode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum LoggerLogLevel {
    None,
    Minimal,
    Headers,
    Body,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LoggerLogLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "LoggerLogLevel::{}", match *self {
            LoggerLogLevel::None => "None",
            LoggerLogLevel::Minimal => "Minimal",
            LoggerLogLevel::Headers => "Headers",
            LoggerLogLevel::Body => "Body",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for LoggerLogLevel {
    type GlibType = soup_sys::SoupLoggerLogLevel;

    fn to_glib(&self) -> soup_sys::SoupLoggerLogLevel {
        match *self {
            LoggerLogLevel::None => soup_sys::SOUP_LOGGER_LOG_NONE,
            LoggerLogLevel::Minimal => soup_sys::SOUP_LOGGER_LOG_MINIMAL,
            LoggerLogLevel::Headers => soup_sys::SOUP_LOGGER_LOG_HEADERS,
            LoggerLogLevel::Body => soup_sys::SOUP_LOGGER_LOG_BODY,
            LoggerLogLevel::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupLoggerLogLevel> for LoggerLogLevel {
    fn from_glib(value: soup_sys::SoupLoggerLogLevel) -> Self {
        skip_assert_initialized!();
        match value {
            0 => LoggerLogLevel::None,
            1 => LoggerLogLevel::Minimal,
            2 => LoggerLogLevel::Headers,
            3 => LoggerLogLevel::Body,
            value => LoggerLogLevel::__Unknown(value),
        }
    }
}

impl StaticType for LoggerLogLevel {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_logger_log_level_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for LoggerLogLevel {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for LoggerLogLevel {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for LoggerLogLevel {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum MemoryUse {
    Static,
    Take,
    Copy,
    Temporary,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MemoryUse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "MemoryUse::{}", match *self {
            MemoryUse::Static => "Static",
            MemoryUse::Take => "Take",
            MemoryUse::Copy => "Copy",
            MemoryUse::Temporary => "Temporary",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for MemoryUse {
    type GlibType = soup_sys::SoupMemoryUse;

    fn to_glib(&self) -> soup_sys::SoupMemoryUse {
        match *self {
            MemoryUse::Static => soup_sys::SOUP_MEMORY_STATIC,
            MemoryUse::Take => soup_sys::SOUP_MEMORY_TAKE,
            MemoryUse::Copy => soup_sys::SOUP_MEMORY_COPY,
            MemoryUse::Temporary => soup_sys::SOUP_MEMORY_TEMPORARY,
            MemoryUse::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupMemoryUse> for MemoryUse {
    fn from_glib(value: soup_sys::SoupMemoryUse) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MemoryUse::Static,
            1 => MemoryUse::Take,
            2 => MemoryUse::Copy,
            3 => MemoryUse::Temporary,
            value => MemoryUse::__Unknown(value),
        }
    }
}

impl StaticType for MemoryUse {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_memory_use_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MemoryUse {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MemoryUse {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MemoryUse {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum MessageHeadersType {
    Request,
    Response,
    Multipart,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MessageHeadersType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "MessageHeadersType::{}", match *self {
            MessageHeadersType::Request => "Request",
            MessageHeadersType::Response => "Response",
            MessageHeadersType::Multipart => "Multipart",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for MessageHeadersType {
    type GlibType = soup_sys::SoupMessageHeadersType;

    fn to_glib(&self) -> soup_sys::SoupMessageHeadersType {
        match *self {
            MessageHeadersType::Request => soup_sys::SOUP_MESSAGE_HEADERS_REQUEST,
            MessageHeadersType::Response => soup_sys::SOUP_MESSAGE_HEADERS_RESPONSE,
            MessageHeadersType::Multipart => soup_sys::SOUP_MESSAGE_HEADERS_MULTIPART,
            MessageHeadersType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupMessageHeadersType> for MessageHeadersType {
    fn from_glib(value: soup_sys::SoupMessageHeadersType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MessageHeadersType::Request,
            1 => MessageHeadersType::Response,
            2 => MessageHeadersType::Multipart,
            value => MessageHeadersType::__Unknown(value),
        }
    }
}

impl StaticType for MessageHeadersType {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_message_headers_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MessageHeadersType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MessageHeadersType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MessageHeadersType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum MessagePriority {
    VeryLow,
    Low,
    Normal,
    High,
    VeryHigh,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for MessagePriority {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "MessagePriority::{}", match *self {
            MessagePriority::VeryLow => "VeryLow",
            MessagePriority::Low => "Low",
            MessagePriority::Normal => "Normal",
            MessagePriority::High => "High",
            MessagePriority::VeryHigh => "VeryHigh",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for MessagePriority {
    type GlibType = soup_sys::SoupMessagePriority;

    fn to_glib(&self) -> soup_sys::SoupMessagePriority {
        match *self {
            MessagePriority::VeryLow => soup_sys::SOUP_MESSAGE_PRIORITY_VERY_LOW,
            MessagePriority::Low => soup_sys::SOUP_MESSAGE_PRIORITY_LOW,
            MessagePriority::Normal => soup_sys::SOUP_MESSAGE_PRIORITY_NORMAL,
            MessagePriority::High => soup_sys::SOUP_MESSAGE_PRIORITY_HIGH,
            MessagePriority::VeryHigh => soup_sys::SOUP_MESSAGE_PRIORITY_VERY_HIGH,
            MessagePriority::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupMessagePriority> for MessagePriority {
    fn from_glib(value: soup_sys::SoupMessagePriority) -> Self {
        skip_assert_initialized!();
        match value {
            0 => MessagePriority::VeryLow,
            1 => MessagePriority::Low,
            2 => MessagePriority::Normal,
            3 => MessagePriority::High,
            4 => MessagePriority::VeryHigh,
            value => MessagePriority::__Unknown(value),
        }
    }
}

impl StaticType for MessagePriority {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_message_priority_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for MessagePriority {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for MessagePriority {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for MessagePriority {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum RequestError {
    BadUri,
    UnsupportedUriScheme,
    Parsing,
    Encoding,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl fmt::Display for RequestError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "RequestError::{}", match *self {
            RequestError::BadUri => "BadUri",
            RequestError::UnsupportedUriScheme => "UnsupportedUriScheme",
            RequestError::Parsing => "Parsing",
            RequestError::Encoding => "Encoding",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for RequestError {
    type GlibType = soup_sys::SoupRequestError;

    fn to_glib(&self) -> soup_sys::SoupRequestError {
        match *self {
            RequestError::BadUri => soup_sys::SOUP_REQUEST_ERROR_BAD_URI,
            RequestError::UnsupportedUriScheme => soup_sys::SOUP_REQUEST_ERROR_UNSUPPORTED_URI_SCHEME,
            RequestError::Parsing => soup_sys::SOUP_REQUEST_ERROR_PARSING,
            RequestError::Encoding => soup_sys::SOUP_REQUEST_ERROR_ENCODING,
            RequestError::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupRequestError> for RequestError {
    fn from_glib(value: soup_sys::SoupRequestError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RequestError::BadUri,
            1 => RequestError::UnsupportedUriScheme,
            2 => RequestError::Parsing,
            3 => RequestError::Encoding,
            value => RequestError::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl ErrorDomain for RequestError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(soup_sys::soup_request_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(RequestError::BadUri),
            1 => Some(RequestError::UnsupportedUriScheme),
            2 => Some(RequestError::Parsing),
            3 => Some(RequestError::Encoding),
            value => Some(RequestError::__Unknown(value)),
        }
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl StaticType for RequestError {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_request_error_get_type()) }
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl<'a> FromValueOptional<'a> for RequestError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl<'a> FromValue<'a> for RequestError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_42", feature = "dox"))]
impl SetValue for RequestError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum RequesterError {
    BadUri,
    UnsupportedUriScheme,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RequesterError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "RequesterError::{}", match *self {
            RequesterError::BadUri => "BadUri",
            RequesterError::UnsupportedUriScheme => "UnsupportedUriScheme",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for RequesterError {
    type GlibType = soup_sys::SoupRequesterError;

    fn to_glib(&self) -> soup_sys::SoupRequesterError {
        match *self {
            RequesterError::BadUri => soup_sys::SOUP_REQUESTER_ERROR_BAD_URI,
            RequesterError::UnsupportedUriScheme => soup_sys::SOUP_REQUESTER_ERROR_UNSUPPORTED_URI_SCHEME,
            RequesterError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupRequesterError> for RequesterError {
    fn from_glib(value: soup_sys::SoupRequesterError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RequesterError::BadUri,
            1 => RequesterError::UnsupportedUriScheme,
            value => RequesterError::__Unknown(value),
        }
    }
}

impl ErrorDomain for RequesterError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(soup_sys::soup_requester_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(RequesterError::BadUri),
            1 => Some(RequesterError::UnsupportedUriScheme),
            value => Some(RequesterError::__Unknown(value)),
        }
    }
}

impl StaticType for RequesterError {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_requester_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for RequesterError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for RequesterError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for RequesterError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum SocketIOStatus {
    Ok,
    WouldBlock,
    Eof,
    Error,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SocketIOStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SocketIOStatus::{}", match *self {
            SocketIOStatus::Ok => "Ok",
            SocketIOStatus::WouldBlock => "WouldBlock",
            SocketIOStatus::Eof => "Eof",
            SocketIOStatus::Error => "Error",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SocketIOStatus {
    type GlibType = soup_sys::SoupSocketIOStatus;

    fn to_glib(&self) -> soup_sys::SoupSocketIOStatus {
        match *self {
            SocketIOStatus::Ok => soup_sys::SOUP_SOCKET_OK,
            SocketIOStatus::WouldBlock => soup_sys::SOUP_SOCKET_WOULD_BLOCK,
            SocketIOStatus::Eof => soup_sys::SOUP_SOCKET_EOF,
            SocketIOStatus::Error => soup_sys::SOUP_SOCKET_ERROR,
            SocketIOStatus::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupSocketIOStatus> for SocketIOStatus {
    fn from_glib(value: soup_sys::SoupSocketIOStatus) -> Self {
        skip_assert_initialized!();
        match value {
            0 => SocketIOStatus::Ok,
            1 => SocketIOStatus::WouldBlock,
            2 => SocketIOStatus::Eof,
            3 => SocketIOStatus::Error,
            value => SocketIOStatus::__Unknown(value),
        }
    }
}

impl StaticType for SocketIOStatus {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_socket_io_status_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for SocketIOStatus {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for SocketIOStatus {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for SocketIOStatus {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum Status {
    None,
    Cancelled,
    CantResolve,
    CantResolveProxy,
    CantConnect,
    CantConnectProxy,
    SslFailed,
    IoError,
    Malformed,
    TryAgain,
    TooManyRedirects,
    TlsFailed,
    Continue,
    SwitchingProtocols,
    Processing,
    Ok,
    Created,
    Accepted,
    NonAuthoritative,
    NoContent,
    ResetContent,
    PartialContent,
    MultiStatus,
    MultipleChoices,
    MovedPermanently,
    Found,
    SeeOther,
    NotModified,
    UseProxy,
    NotAppearingInThisProtocol,
    TemporaryRedirect,
    BadRequest,
    Unauthorized,
    PaymentRequired,
    Forbidden,
    NotFound,
    MethodNotAllowed,
    NotAcceptable,
    ProxyAuthenticationRequired,
    RequestTimeout,
    Conflict,
    Gone,
    LengthRequired,
    PreconditionFailed,
    RequestEntityTooLarge,
    RequestUriTooLong,
    UnsupportedMediaType,
    RequestedRangeNotSatisfiable,
    ExpectationFailed,
    UnprocessableEntity,
    Locked,
    FailedDependency,
    InternalServerError,
    NotImplemented,
    BadGateway,
    ServiceUnavailable,
    GatewayTimeout,
    HttpVersionNotSupported,
    InsufficientStorage,
    NotExtended,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Status {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Status::{}", match *self {
            Status::None => "None",
            Status::Cancelled => "Cancelled",
            Status::CantResolve => "CantResolve",
            Status::CantResolveProxy => "CantResolveProxy",
            Status::CantConnect => "CantConnect",
            Status::CantConnectProxy => "CantConnectProxy",
            Status::SslFailed => "SslFailed",
            Status::IoError => "IoError",
            Status::Malformed => "Malformed",
            Status::TryAgain => "TryAgain",
            Status::TooManyRedirects => "TooManyRedirects",
            Status::TlsFailed => "TlsFailed",
            Status::Continue => "Continue",
            Status::SwitchingProtocols => "SwitchingProtocols",
            Status::Processing => "Processing",
            Status::Ok => "Ok",
            Status::Created => "Created",
            Status::Accepted => "Accepted",
            Status::NonAuthoritative => "NonAuthoritative",
            Status::NoContent => "NoContent",
            Status::ResetContent => "ResetContent",
            Status::PartialContent => "PartialContent",
            Status::MultiStatus => "MultiStatus",
            Status::MultipleChoices => "MultipleChoices",
            Status::MovedPermanently => "MovedPermanently",
            Status::Found => "Found",
            Status::SeeOther => "SeeOther",
            Status::NotModified => "NotModified",
            Status::UseProxy => "UseProxy",
            Status::NotAppearingInThisProtocol => "NotAppearingInThisProtocol",
            Status::TemporaryRedirect => "TemporaryRedirect",
            Status::BadRequest => "BadRequest",
            Status::Unauthorized => "Unauthorized",
            Status::PaymentRequired => "PaymentRequired",
            Status::Forbidden => "Forbidden",
            Status::NotFound => "NotFound",
            Status::MethodNotAllowed => "MethodNotAllowed",
            Status::NotAcceptable => "NotAcceptable",
            Status::ProxyAuthenticationRequired => "ProxyAuthenticationRequired",
            Status::RequestTimeout => "RequestTimeout",
            Status::Conflict => "Conflict",
            Status::Gone => "Gone",
            Status::LengthRequired => "LengthRequired",
            Status::PreconditionFailed => "PreconditionFailed",
            Status::RequestEntityTooLarge => "RequestEntityTooLarge",
            Status::RequestUriTooLong => "RequestUriTooLong",
            Status::UnsupportedMediaType => "UnsupportedMediaType",
            Status::RequestedRangeNotSatisfiable => "RequestedRangeNotSatisfiable",
            Status::ExpectationFailed => "ExpectationFailed",
            Status::UnprocessableEntity => "UnprocessableEntity",
            Status::Locked => "Locked",
            Status::FailedDependency => "FailedDependency",
            Status::InternalServerError => "InternalServerError",
            Status::NotImplemented => "NotImplemented",
            Status::BadGateway => "BadGateway",
            Status::ServiceUnavailable => "ServiceUnavailable",
            Status::GatewayTimeout => "GatewayTimeout",
            Status::HttpVersionNotSupported => "HttpVersionNotSupported",
            Status::InsufficientStorage => "InsufficientStorage",
            Status::NotExtended => "NotExtended",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Status {
    type GlibType = soup_sys::SoupStatus;

    fn to_glib(&self) -> soup_sys::SoupStatus {
        match *self {
            Status::None => soup_sys::SOUP_STATUS_NONE,
            Status::Cancelled => soup_sys::SOUP_STATUS_CANCELLED,
            Status::CantResolve => soup_sys::SOUP_STATUS_CANT_RESOLVE,
            Status::CantResolveProxy => soup_sys::SOUP_STATUS_CANT_RESOLVE_PROXY,
            Status::CantConnect => soup_sys::SOUP_STATUS_CANT_CONNECT,
            Status::CantConnectProxy => soup_sys::SOUP_STATUS_CANT_CONNECT_PROXY,
            Status::SslFailed => soup_sys::SOUP_STATUS_SSL_FAILED,
            Status::IoError => soup_sys::SOUP_STATUS_IO_ERROR,
            Status::Malformed => soup_sys::SOUP_STATUS_MALFORMED,
            Status::TryAgain => soup_sys::SOUP_STATUS_TRY_AGAIN,
            Status::TooManyRedirects => soup_sys::SOUP_STATUS_TOO_MANY_REDIRECTS,
            Status::TlsFailed => soup_sys::SOUP_STATUS_TLS_FAILED,
            Status::Continue => soup_sys::SOUP_STATUS_CONTINUE,
            Status::SwitchingProtocols => soup_sys::SOUP_STATUS_SWITCHING_PROTOCOLS,
            Status::Processing => soup_sys::SOUP_STATUS_PROCESSING,
            Status::Ok => soup_sys::SOUP_STATUS_OK,
            Status::Created => soup_sys::SOUP_STATUS_CREATED,
            Status::Accepted => soup_sys::SOUP_STATUS_ACCEPTED,
            Status::NonAuthoritative => soup_sys::SOUP_STATUS_NON_AUTHORITATIVE,
            Status::NoContent => soup_sys::SOUP_STATUS_NO_CONTENT,
            Status::ResetContent => soup_sys::SOUP_STATUS_RESET_CONTENT,
            Status::PartialContent => soup_sys::SOUP_STATUS_PARTIAL_CONTENT,
            Status::MultiStatus => soup_sys::SOUP_STATUS_MULTI_STATUS,
            Status::MultipleChoices => soup_sys::SOUP_STATUS_MULTIPLE_CHOICES,
            Status::MovedPermanently => soup_sys::SOUP_STATUS_MOVED_PERMANENTLY,
            Status::Found => soup_sys::SOUP_STATUS_FOUND,
            Status::SeeOther => soup_sys::SOUP_STATUS_SEE_OTHER,
            Status::NotModified => soup_sys::SOUP_STATUS_NOT_MODIFIED,
            Status::UseProxy => soup_sys::SOUP_STATUS_USE_PROXY,
            Status::NotAppearingInThisProtocol => soup_sys::SOUP_STATUS_NOT_APPEARING_IN_THIS_PROTOCOL,
            Status::TemporaryRedirect => soup_sys::SOUP_STATUS_TEMPORARY_REDIRECT,
            Status::BadRequest => soup_sys::SOUP_STATUS_BAD_REQUEST,
            Status::Unauthorized => soup_sys::SOUP_STATUS_UNAUTHORIZED,
            Status::PaymentRequired => soup_sys::SOUP_STATUS_PAYMENT_REQUIRED,
            Status::Forbidden => soup_sys::SOUP_STATUS_FORBIDDEN,
            Status::NotFound => soup_sys::SOUP_STATUS_NOT_FOUND,
            Status::MethodNotAllowed => soup_sys::SOUP_STATUS_METHOD_NOT_ALLOWED,
            Status::NotAcceptable => soup_sys::SOUP_STATUS_NOT_ACCEPTABLE,
            Status::ProxyAuthenticationRequired => soup_sys::SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED,
            Status::RequestTimeout => soup_sys::SOUP_STATUS_REQUEST_TIMEOUT,
            Status::Conflict => soup_sys::SOUP_STATUS_CONFLICT,
            Status::Gone => soup_sys::SOUP_STATUS_GONE,
            Status::LengthRequired => soup_sys::SOUP_STATUS_LENGTH_REQUIRED,
            Status::PreconditionFailed => soup_sys::SOUP_STATUS_PRECONDITION_FAILED,
            Status::RequestEntityTooLarge => soup_sys::SOUP_STATUS_REQUEST_ENTITY_TOO_LARGE,
            Status::RequestUriTooLong => soup_sys::SOUP_STATUS_REQUEST_URI_TOO_LONG,
            Status::UnsupportedMediaType => soup_sys::SOUP_STATUS_UNSUPPORTED_MEDIA_TYPE,
            Status::RequestedRangeNotSatisfiable => soup_sys::SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE,
            Status::ExpectationFailed => soup_sys::SOUP_STATUS_EXPECTATION_FAILED,
            Status::UnprocessableEntity => soup_sys::SOUP_STATUS_UNPROCESSABLE_ENTITY,
            Status::Locked => soup_sys::SOUP_STATUS_LOCKED,
            Status::FailedDependency => soup_sys::SOUP_STATUS_FAILED_DEPENDENCY,
            Status::InternalServerError => soup_sys::SOUP_STATUS_INTERNAL_SERVER_ERROR,
            Status::NotImplemented => soup_sys::SOUP_STATUS_NOT_IMPLEMENTED,
            Status::BadGateway => soup_sys::SOUP_STATUS_BAD_GATEWAY,
            Status::ServiceUnavailable => soup_sys::SOUP_STATUS_SERVICE_UNAVAILABLE,
            Status::GatewayTimeout => soup_sys::SOUP_STATUS_GATEWAY_TIMEOUT,
            Status::HttpVersionNotSupported => soup_sys::SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED,
            Status::InsufficientStorage => soup_sys::SOUP_STATUS_INSUFFICIENT_STORAGE,
            Status::NotExtended => soup_sys::SOUP_STATUS_NOT_EXTENDED,
            Status::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupStatus> for Status {
    fn from_glib(value: soup_sys::SoupStatus) -> Self {
        skip_assert_initialized!();
        match value {
            0 => Status::None,
            1 => Status::Cancelled,
            2 => Status::CantResolve,
            3 => Status::CantResolveProxy,
            4 => Status::CantConnect,
            5 => Status::CantConnectProxy,
            6 => Status::SslFailed,
            7 => Status::IoError,
            8 => Status::Malformed,
            9 => Status::TryAgain,
            10 => Status::TooManyRedirects,
            11 => Status::TlsFailed,
            100 => Status::Continue,
            101 => Status::SwitchingProtocols,
            102 => Status::Processing,
            200 => Status::Ok,
            201 => Status::Created,
            202 => Status::Accepted,
            203 => Status::NonAuthoritative,
            204 => Status::NoContent,
            205 => Status::ResetContent,
            206 => Status::PartialContent,
            207 => Status::MultiStatus,
            300 => Status::MultipleChoices,
            301 => Status::MovedPermanently,
            302 => Status::Found,
            303 => Status::SeeOther,
            304 => Status::NotModified,
            305 => Status::UseProxy,
            306 => Status::NotAppearingInThisProtocol,
            307 => Status::TemporaryRedirect,
            400 => Status::BadRequest,
            401 => Status::Unauthorized,
            402 => Status::PaymentRequired,
            403 => Status::Forbidden,
            404 => Status::NotFound,
            405 => Status::MethodNotAllowed,
            406 => Status::NotAcceptable,
            407 => Status::ProxyAuthenticationRequired,
            408 => Status::RequestTimeout,
            409 => Status::Conflict,
            410 => Status::Gone,
            411 => Status::LengthRequired,
            412 => Status::PreconditionFailed,
            413 => Status::RequestEntityTooLarge,
            414 => Status::RequestUriTooLong,
            415 => Status::UnsupportedMediaType,
            416 => Status::RequestedRangeNotSatisfiable,
            417 => Status::ExpectationFailed,
            422 => Status::UnprocessableEntity,
            423 => Status::Locked,
            424 => Status::FailedDependency,
            500 => Status::InternalServerError,
            501 => Status::NotImplemented,
            502 => Status::BadGateway,
            503 => Status::ServiceUnavailable,
            504 => Status::GatewayTimeout,
            505 => Status::HttpVersionNotSupported,
            507 => Status::InsufficientStorage,
            510 => Status::NotExtended,
            value => Status::__Unknown(value),
        }
    }
}

impl StaticType for Status {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_status_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for Status {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for Status {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for Status {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum WebsocketCloseCode {
    Normal,
    GoingAway,
    ProtocolError,
    UnsupportedData,
    NoStatus,
    Abnormal,
    BadData,
    PolicyViolation,
    TooBig,
    NoExtension,
    ServerError,
    TlsHandshake,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl fmt::Display for WebsocketCloseCode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WebsocketCloseCode::{}", match *self {
            WebsocketCloseCode::Normal => "Normal",
            WebsocketCloseCode::GoingAway => "GoingAway",
            WebsocketCloseCode::ProtocolError => "ProtocolError",
            WebsocketCloseCode::UnsupportedData => "UnsupportedData",
            WebsocketCloseCode::NoStatus => "NoStatus",
            WebsocketCloseCode::Abnormal => "Abnormal",
            WebsocketCloseCode::BadData => "BadData",
            WebsocketCloseCode::PolicyViolation => "PolicyViolation",
            WebsocketCloseCode::TooBig => "TooBig",
            WebsocketCloseCode::NoExtension => "NoExtension",
            WebsocketCloseCode::ServerError => "ServerError",
            WebsocketCloseCode::TlsHandshake => "TlsHandshake",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebsocketCloseCode {
    type GlibType = soup_sys::SoupWebsocketCloseCode;

    fn to_glib(&self) -> soup_sys::SoupWebsocketCloseCode {
        match *self {
            WebsocketCloseCode::Normal => soup_sys::SOUP_WEBSOCKET_CLOSE_NORMAL,
            WebsocketCloseCode::GoingAway => soup_sys::SOUP_WEBSOCKET_CLOSE_GOING_AWAY,
            WebsocketCloseCode::ProtocolError => soup_sys::SOUP_WEBSOCKET_CLOSE_PROTOCOL_ERROR,
            WebsocketCloseCode::UnsupportedData => soup_sys::SOUP_WEBSOCKET_CLOSE_UNSUPPORTED_DATA,
            WebsocketCloseCode::NoStatus => soup_sys::SOUP_WEBSOCKET_CLOSE_NO_STATUS,
            WebsocketCloseCode::Abnormal => soup_sys::SOUP_WEBSOCKET_CLOSE_ABNORMAL,
            WebsocketCloseCode::BadData => soup_sys::SOUP_WEBSOCKET_CLOSE_BAD_DATA,
            WebsocketCloseCode::PolicyViolation => soup_sys::SOUP_WEBSOCKET_CLOSE_POLICY_VIOLATION,
            WebsocketCloseCode::TooBig => soup_sys::SOUP_WEBSOCKET_CLOSE_TOO_BIG,
            WebsocketCloseCode::NoExtension => soup_sys::SOUP_WEBSOCKET_CLOSE_NO_EXTENSION,
            WebsocketCloseCode::ServerError => soup_sys::SOUP_WEBSOCKET_CLOSE_SERVER_ERROR,
            WebsocketCloseCode::TlsHandshake => soup_sys::SOUP_WEBSOCKET_CLOSE_TLS_HANDSHAKE,
            WebsocketCloseCode::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupWebsocketCloseCode> for WebsocketCloseCode {
    fn from_glib(value: soup_sys::SoupWebsocketCloseCode) -> Self {
        skip_assert_initialized!();
        match value {
            1000 => WebsocketCloseCode::Normal,
            1001 => WebsocketCloseCode::GoingAway,
            1002 => WebsocketCloseCode::ProtocolError,
            1003 => WebsocketCloseCode::UnsupportedData,
            1005 => WebsocketCloseCode::NoStatus,
            1006 => WebsocketCloseCode::Abnormal,
            1007 => WebsocketCloseCode::BadData,
            1008 => WebsocketCloseCode::PolicyViolation,
            1009 => WebsocketCloseCode::TooBig,
            1010 => WebsocketCloseCode::NoExtension,
            1011 => WebsocketCloseCode::ServerError,
            1015 => WebsocketCloseCode::TlsHandshake,
            value => WebsocketCloseCode::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl StaticType for WebsocketCloseCode {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_websocket_close_code_get_type()) }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebsocketCloseCode {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValue<'a> for WebsocketCloseCode {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl SetValue for WebsocketCloseCode {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum WebsocketConnectionType {
    Unknown,
    Client,
    Server,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl fmt::Display for WebsocketConnectionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WebsocketConnectionType::{}", match *self {
            WebsocketConnectionType::Unknown => "Unknown",
            WebsocketConnectionType::Client => "Client",
            WebsocketConnectionType::Server => "Server",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebsocketConnectionType {
    type GlibType = soup_sys::SoupWebsocketConnectionType;

    fn to_glib(&self) -> soup_sys::SoupWebsocketConnectionType {
        match *self {
            WebsocketConnectionType::Unknown => soup_sys::SOUP_WEBSOCKET_CONNECTION_UNKNOWN,
            WebsocketConnectionType::Client => soup_sys::SOUP_WEBSOCKET_CONNECTION_CLIENT,
            WebsocketConnectionType::Server => soup_sys::SOUP_WEBSOCKET_CONNECTION_SERVER,
            WebsocketConnectionType::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupWebsocketConnectionType> for WebsocketConnectionType {
    fn from_glib(value: soup_sys::SoupWebsocketConnectionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebsocketConnectionType::Unknown,
            1 => WebsocketConnectionType::Client,
            2 => WebsocketConnectionType::Server,
            value => WebsocketConnectionType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl StaticType for WebsocketConnectionType {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_websocket_connection_type_get_type()) }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebsocketConnectionType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValue<'a> for WebsocketConnectionType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl SetValue for WebsocketConnectionType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum WebsocketDataType {
    Text,
    Binary,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl fmt::Display for WebsocketDataType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WebsocketDataType::{}", match *self {
            WebsocketDataType::Text => "Text",
            WebsocketDataType::Binary => "Binary",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebsocketDataType {
    type GlibType = soup_sys::SoupWebsocketDataType;

    fn to_glib(&self) -> soup_sys::SoupWebsocketDataType {
        match *self {
            WebsocketDataType::Text => soup_sys::SOUP_WEBSOCKET_DATA_TEXT,
            WebsocketDataType::Binary => soup_sys::SOUP_WEBSOCKET_DATA_BINARY,
            WebsocketDataType::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupWebsocketDataType> for WebsocketDataType {
    fn from_glib(value: soup_sys::SoupWebsocketDataType) -> Self {
        skip_assert_initialized!();
        match value {
            1 => WebsocketDataType::Text,
            2 => WebsocketDataType::Binary,
            value => WebsocketDataType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl StaticType for WebsocketDataType {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_websocket_data_type_get_type()) }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebsocketDataType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValue<'a> for WebsocketDataType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl SetValue for WebsocketDataType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum WebsocketError {
    Failed,
    NotWebsocket,
    BadHandshake,
    BadOrigin,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl fmt::Display for WebsocketError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WebsocketError::{}", match *self {
            WebsocketError::Failed => "Failed",
            WebsocketError::NotWebsocket => "NotWebsocket",
            WebsocketError::BadHandshake => "BadHandshake",
            WebsocketError::BadOrigin => "BadOrigin",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebsocketError {
    type GlibType = soup_sys::SoupWebsocketError;

    fn to_glib(&self) -> soup_sys::SoupWebsocketError {
        match *self {
            WebsocketError::Failed => soup_sys::SOUP_WEBSOCKET_ERROR_FAILED,
            WebsocketError::NotWebsocket => soup_sys::SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET,
            WebsocketError::BadHandshake => soup_sys::SOUP_WEBSOCKET_ERROR_BAD_HANDSHAKE,
            WebsocketError::BadOrigin => soup_sys::SOUP_WEBSOCKET_ERROR_BAD_ORIGIN,
            WebsocketError::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupWebsocketError> for WebsocketError {
    fn from_glib(value: soup_sys::SoupWebsocketError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebsocketError::Failed,
            1 => WebsocketError::NotWebsocket,
            2 => WebsocketError::BadHandshake,
            3 => WebsocketError::BadOrigin,
            value => WebsocketError::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl StaticType for WebsocketError {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_websocket_error_get_type()) }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebsocketError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValue<'a> for WebsocketError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl SetValue for WebsocketError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum WebsocketState {
    Open,
    Closing,
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl fmt::Display for WebsocketState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WebsocketState::{}", match *self {
            WebsocketState::Open => "Open",
            WebsocketState::Closing => "Closing",
            WebsocketState::Closed => "Closed",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebsocketState {
    type GlibType = soup_sys::SoupWebsocketState;

    fn to_glib(&self) -> soup_sys::SoupWebsocketState {
        match *self {
            WebsocketState::Open => soup_sys::SOUP_WEBSOCKET_STATE_OPEN,
            WebsocketState::Closing => soup_sys::SOUP_WEBSOCKET_STATE_CLOSING,
            WebsocketState::Closed => soup_sys::SOUP_WEBSOCKET_STATE_CLOSED,
            WebsocketState::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<soup_sys::SoupWebsocketState> for WebsocketState {
    fn from_glib(value: soup_sys::SoupWebsocketState) -> Self {
        skip_assert_initialized!();
        match value {
            1 => WebsocketState::Open,
            2 => WebsocketState::Closing,
            3 => WebsocketState::Closed,
            value => WebsocketState::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl StaticType for WebsocketState {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_websocket_state_get_type()) }
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebsocketState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl<'a> FromValue<'a> for WebsocketState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_50", feature = "dox"))]
impl SetValue for WebsocketState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum XMLRPCError {
    Arguments,
    Retval,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for XMLRPCError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "XMLRPCError::{}", match *self {
            XMLRPCError::Arguments => "Arguments",
            XMLRPCError::Retval => "Retval",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for XMLRPCError {
    type GlibType = soup_sys::SoupXMLRPCError;

    fn to_glib(&self) -> soup_sys::SoupXMLRPCError {
        match *self {
            XMLRPCError::Arguments => soup_sys::SOUP_XMLRPC_ERROR_ARGUMENTS,
            XMLRPCError::Retval => soup_sys::SOUP_XMLRPC_ERROR_RETVAL,
            XMLRPCError::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupXMLRPCError> for XMLRPCError {
    fn from_glib(value: soup_sys::SoupXMLRPCError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => XMLRPCError::Arguments,
            1 => XMLRPCError::Retval,
            value => XMLRPCError::__Unknown(value),
        }
    }
}

impl ErrorDomain for XMLRPCError {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(soup_sys::soup_xmlrpc_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(XMLRPCError::Arguments),
            1 => Some(XMLRPCError::Retval),
            value => Some(XMLRPCError::__Unknown(value)),
        }
    }
}

impl StaticType for XMLRPCError {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_xmlrpc_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for XMLRPCError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for XMLRPCError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for XMLRPCError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum XMLRPCFault {
    ParseErrorNotWellFormed,
    ParseErrorUnsupportedEncoding,
    ParseErrorInvalidCharacterForEncoding,
    ServerErrorInvalidXmlRpc,
    ServerErrorRequestedMethodNotFound,
    ServerErrorInvalidMethodParameters,
    ServerErrorInternalXmlRpcError,
    ApplicationError,
    SystemError,
    TransportError,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for XMLRPCFault {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "XMLRPCFault::{}", match *self {
            XMLRPCFault::ParseErrorNotWellFormed => "ParseErrorNotWellFormed",
            XMLRPCFault::ParseErrorUnsupportedEncoding => "ParseErrorUnsupportedEncoding",
            XMLRPCFault::ParseErrorInvalidCharacterForEncoding => "ParseErrorInvalidCharacterForEncoding",
            XMLRPCFault::ServerErrorInvalidXmlRpc => "ServerErrorInvalidXmlRpc",
            XMLRPCFault::ServerErrorRequestedMethodNotFound => "ServerErrorRequestedMethodNotFound",
            XMLRPCFault::ServerErrorInvalidMethodParameters => "ServerErrorInvalidMethodParameters",
            XMLRPCFault::ServerErrorInternalXmlRpcError => "ServerErrorInternalXmlRpcError",
            XMLRPCFault::ApplicationError => "ApplicationError",
            XMLRPCFault::SystemError => "SystemError",
            XMLRPCFault::TransportError => "TransportError",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for XMLRPCFault {
    type GlibType = soup_sys::SoupXMLRPCFault;

    fn to_glib(&self) -> soup_sys::SoupXMLRPCFault {
        match *self {
            XMLRPCFault::ParseErrorNotWellFormed => soup_sys::SOUP_XMLRPC_FAULT_PARSE_ERROR_NOT_WELL_FORMED,
            XMLRPCFault::ParseErrorUnsupportedEncoding => soup_sys::SOUP_XMLRPC_FAULT_PARSE_ERROR_UNSUPPORTED_ENCODING,
            XMLRPCFault::ParseErrorInvalidCharacterForEncoding => soup_sys::SOUP_XMLRPC_FAULT_PARSE_ERROR_INVALID_CHARACTER_FOR_ENCODING,
            XMLRPCFault::ServerErrorInvalidXmlRpc => soup_sys::SOUP_XMLRPC_FAULT_SERVER_ERROR_INVALID_XML_RPC,
            XMLRPCFault::ServerErrorRequestedMethodNotFound => soup_sys::SOUP_XMLRPC_FAULT_SERVER_ERROR_REQUESTED_METHOD_NOT_FOUND,
            XMLRPCFault::ServerErrorInvalidMethodParameters => soup_sys::SOUP_XMLRPC_FAULT_SERVER_ERROR_INVALID_METHOD_PARAMETERS,
            XMLRPCFault::ServerErrorInternalXmlRpcError => soup_sys::SOUP_XMLRPC_FAULT_SERVER_ERROR_INTERNAL_XML_RPC_ERROR,
            XMLRPCFault::ApplicationError => soup_sys::SOUP_XMLRPC_FAULT_APPLICATION_ERROR,
            XMLRPCFault::SystemError => soup_sys::SOUP_XMLRPC_FAULT_SYSTEM_ERROR,
            XMLRPCFault::TransportError => soup_sys::SOUP_XMLRPC_FAULT_TRANSPORT_ERROR,
            XMLRPCFault::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<soup_sys::SoupXMLRPCFault> for XMLRPCFault {
    fn from_glib(value: soup_sys::SoupXMLRPCFault) -> Self {
        skip_assert_initialized!();
        match value {
            -32700 => XMLRPCFault::ParseErrorNotWellFormed,
            -32701 => XMLRPCFault::ParseErrorUnsupportedEncoding,
            -32702 => XMLRPCFault::ParseErrorInvalidCharacterForEncoding,
            -32600 => XMLRPCFault::ServerErrorInvalidXmlRpc,
            -32601 => XMLRPCFault::ServerErrorRequestedMethodNotFound,
            -32602 => XMLRPCFault::ServerErrorInvalidMethodParameters,
            -32603 => XMLRPCFault::ServerErrorInternalXmlRpcError,
            -32500 => XMLRPCFault::ApplicationError,
            -32400 => XMLRPCFault::SystemError,
            -32300 => XMLRPCFault::TransportError,
            value => XMLRPCFault::__Unknown(value),
        }
    }
}

impl ErrorDomain for XMLRPCFault {
    fn domain() -> Quark {
        skip_assert_initialized!();
        unsafe { from_glib(soup_sys::soup_xmlrpc_fault_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            -32700 => Some(XMLRPCFault::ParseErrorNotWellFormed),
            -32701 => Some(XMLRPCFault::ParseErrorUnsupportedEncoding),
            -32702 => Some(XMLRPCFault::ParseErrorInvalidCharacterForEncoding),
            -32600 => Some(XMLRPCFault::ServerErrorInvalidXmlRpc),
            -32601 => Some(XMLRPCFault::ServerErrorRequestedMethodNotFound),
            -32602 => Some(XMLRPCFault::ServerErrorInvalidMethodParameters),
            -32603 => Some(XMLRPCFault::ServerErrorInternalXmlRpcError),
            -32500 => Some(XMLRPCFault::ApplicationError),
            -32400 => Some(XMLRPCFault::SystemError),
            -32300 => Some(XMLRPCFault::TransportError),
            value => Some(XMLRPCFault::__Unknown(value)),
        }
    }
}

impl StaticType for XMLRPCFault {
    fn static_type() -> Type {
        unsafe { from_glib(soup_sys::soup_xmlrpc_fault_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for XMLRPCFault {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for XMLRPCFault {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for XMLRPCFault {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

