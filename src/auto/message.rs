// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

#[cfg(any(feature = "v2_28", feature = "dox"))]
use glib;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value;
use glib_sys;
use gobject_sys;
use soup_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;
#[cfg(any(feature = "v2_26", feature = "dox"))]
use Address;
use HTTPVersion;
use MemoryUse;
use MessagePriority;
#[cfg(any(feature = "v2_42", feature = "dox"))]
use Request;
use URI;

glib_wrapper! {
    pub struct Message(Object<soup_sys::SoupMessage, soup_sys::SoupMessageClass, MessageClass>);

    match fn {
        get_type => || soup_sys::soup_message_get_type(),
    }
}

impl Message {
    pub fn new(method: &str, uri_string: &str) -> Option<Message> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(soup_sys::soup_message_new(method.to_glib_none().0, uri_string.to_glib_none().0))
        }
    }

    pub fn new_from_uri(method: &str, uri: &mut URI) -> Message {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(soup_sys::soup_message_new_from_uri(method.to_glib_none().0, uri.to_glib_none_mut().0))
        }
    }
}

pub const NONE_MESSAGE: Option<&Message> = None;

pub trait MessageExt: 'static {
    //fn add_header_handler<P: Fn() + 'static>(&self, signal: &str, header: &str, callback: P, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) -> u32;

    //fn add_status_code_handler<P: Fn() + 'static>(&self, signal: &str, status_code: u32, callback: P, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) -> u32;

    //fn content_sniffed(&self, content_type: &str, params: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 });

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    fn disable_feature(&self, feature_type: glib::types::Type);

    fn finished(&self);

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    fn get_address(&self) -> Option<Address>;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_first_party(&self) -> Option<URI>;

    //fn get_flags(&self) -> /*Ignored*/MessageFlags;

    fn get_http_version(&self) -> HTTPVersion;

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn get_https_status(&self, certificate: /*Ignored*/gio::TlsCertificate) -> Option</*Ignored*/gio::TlsCertificateFlags>;

    #[cfg(any(feature = "v2_44", feature = "dox"))]
    fn get_priority(&self) -> MessagePriority;

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn get_soup_request(&self) -> Option<Request>;

    fn get_uri(&self) -> Option<URI>;

    fn got_body(&self);

    //fn got_chunk(&self, chunk: /*Ignored*/&mut Buffer);

    fn got_headers(&self);

    fn got_informational(&self);

    fn is_keepalive(&self) -> bool;

    fn restarted(&self);

    //fn set_chunk_allocator(&self, allocator: /*Unimplemented*/Fn(&Message, usize) -> /*Ignored*/Option<Buffer>, user_data: /*Unimplemented*/Option<Fundamental: Pointer>);

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_first_party(&self, first_party: &mut URI);

    //fn set_flags(&self, flags: /*Ignored*/MessageFlags);

    fn set_http_version(&self, version: HTTPVersion);

    #[cfg(any(feature = "v2_44", feature = "dox"))]
    fn set_priority(&self, priority: MessagePriority);

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_redirect(&self, status_code: u32, redirect_uri: &str);

    fn set_request(&self, content_type: Option<&str>, req_use: MemoryUse, req_body: &[u8]);

    fn set_response(&self, content_type: Option<&str>, resp_use: MemoryUse, resp_body: &[u8]);

    fn set_status(&self, status_code: u32);

    fn set_status_full(&self, status_code: u32, reason_phrase: &str);

    fn set_uri(&self, uri: &mut URI);

    fn starting(&self);

    fn wrote_body(&self);

    //fn wrote_body_data(&self, chunk: /*Ignored*/&mut Buffer);

    fn wrote_chunk(&self);

    fn wrote_headers(&self);

    fn wrote_informational(&self);

    fn get_property_method(&self) -> Option<GString>;

    fn set_property_method(&self, method: Option<&str>);

    fn get_property_priority(&self) -> MessagePriority;

    fn set_property_priority(&self, priority: MessagePriority);

    fn get_property_reason_phrase(&self) -> Option<GString>;

    fn set_property_reason_phrase(&self, reason_phrase: Option<&str>);

    //fn get_property_request_body(&self) -> /*Ignored*/Option<MessageBody>;

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn get_property_request_body_data(&self) -> Option<glib::Bytes>;

    //fn get_property_request_headers(&self) -> /*Ignored*/Option<MessageHeaders>;

    //fn get_property_response_body(&self) -> /*Ignored*/Option<MessageBody>;

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn get_property_response_body_data(&self) -> Option<glib::Bytes>;

    //fn get_property_response_headers(&self) -> /*Ignored*/Option<MessageHeaders>;

    fn get_property_server_side(&self) -> bool;

    fn get_property_status_code(&self) -> u32;

    fn set_property_status_code(&self, status_code: u32);

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn get_property_tls_certificate(&self) -> /*Ignored*/Option<gio::TlsCertificate>;

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn set_property_tls_certificate<P: IsA</*Ignored*/gio::TlsCertificate> + SetValueOptional>(&self, tls_certificate: Option<&P>);

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn get_property_tls_errors(&self) -> /*Ignored*/gio::TlsCertificateFlags;

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn set_property_tls_errors(&self, tls_errors: /*Ignored*/gio::TlsCertificateFlags);

    //#[cfg(any(feature = "v2_28", feature = "dox"))]
    //fn connect_content_sniffed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    fn connect_finished<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_got_body<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //fn connect_got_chunk<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    fn connect_got_headers<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_got_informational<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v2_38", feature = "dox"))]
    //fn connect_network_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    fn connect_restarted<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    fn connect_starting<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_wrote_body<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    //#[cfg(any(feature = "v2_24", feature = "dox"))]
    //fn connect_wrote_body_data<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId;

    fn connect_wrote_chunk<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_wrote_headers<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_wrote_informational<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_first_party_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_http_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_method_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_priority_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_reason_phrase_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_request_body_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn connect_property_request_body_data_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_request_headers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_response_body_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn connect_property_response_body_data_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_response_headers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_status_code_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_34", feature = "dox"))]
    fn connect_property_tls_certificate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_34", feature = "dox"))]
    fn connect_property_tls_errors_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    fn connect_property_uri_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Message>> MessageExt for O {
    //fn add_header_handler<P: Fn() + 'static>(&self, signal: &str, header: &str, callback: P, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) -> u32 {
    //    unsafe { TODO: call soup_sys:soup_message_add_header_handler() }
    //}

    //fn add_status_code_handler<P: Fn() + 'static>(&self, signal: &str, status_code: u32, callback: P, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) -> u32 {
    //    unsafe { TODO: call soup_sys:soup_message_add_status_code_handler() }
    //}

    //fn content_sniffed(&self, content_type: &str, params: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 25 }/TypeId { ns_id: 0, id: 25 }) {
    //    unsafe { TODO: call soup_sys:soup_message_content_sniffed() }
    //}

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    fn disable_feature(&self, feature_type: glib::types::Type) {
        unsafe {
            soup_sys::soup_message_disable_feature(self.as_ref().to_glib_none().0, feature_type.to_glib());
        }
    }

    fn finished(&self) {
        unsafe {
            soup_sys::soup_message_finished(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_26", feature = "dox"))]
    fn get_address(&self) -> Option<Address> {
        unsafe {
            from_glib_none(soup_sys::soup_message_get_address(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn get_first_party(&self) -> Option<URI> {
        unsafe {
            from_glib_none(soup_sys::soup_message_get_first_party(self.as_ref().to_glib_none().0))
        }
    }

    //fn get_flags(&self) -> /*Ignored*/MessageFlags {
    //    unsafe { TODO: call soup_sys:soup_message_get_flags() }
    //}

    fn get_http_version(&self) -> HTTPVersion {
        unsafe {
            from_glib(soup_sys::soup_message_get_http_version(self.as_ref().to_glib_none().0))
        }
    }

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn get_https_status(&self, certificate: /*Ignored*/gio::TlsCertificate) -> Option</*Ignored*/gio::TlsCertificateFlags> {
    //    unsafe { TODO: call soup_sys:soup_message_get_https_status() }
    //}

    #[cfg(any(feature = "v2_44", feature = "dox"))]
    fn get_priority(&self) -> MessagePriority {
        unsafe {
            from_glib(soup_sys::soup_message_get_priority(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_42", feature = "dox"))]
    fn get_soup_request(&self) -> Option<Request> {
        unsafe {
            from_glib_none(soup_sys::soup_message_get_soup_request(self.as_ref().to_glib_none().0))
        }
    }

    fn get_uri(&self) -> Option<URI> {
        unsafe {
            from_glib_none(soup_sys::soup_message_get_uri(self.as_ref().to_glib_none().0))
        }
    }

    fn got_body(&self) {
        unsafe {
            soup_sys::soup_message_got_body(self.as_ref().to_glib_none().0);
        }
    }

    //fn got_chunk(&self, chunk: /*Ignored*/&mut Buffer) {
    //    unsafe { TODO: call soup_sys:soup_message_got_chunk() }
    //}

    fn got_headers(&self) {
        unsafe {
            soup_sys::soup_message_got_headers(self.as_ref().to_glib_none().0);
        }
    }

    fn got_informational(&self) {
        unsafe {
            soup_sys::soup_message_got_informational(self.as_ref().to_glib_none().0);
        }
    }

    fn is_keepalive(&self) -> bool {
        unsafe {
            from_glib(soup_sys::soup_message_is_keepalive(self.as_ref().to_glib_none().0))
        }
    }

    fn restarted(&self) {
        unsafe {
            soup_sys::soup_message_restarted(self.as_ref().to_glib_none().0);
        }
    }

    //fn set_chunk_allocator(&self, allocator: /*Unimplemented*/Fn(&Message, usize) -> /*Ignored*/Option<Buffer>, user_data: /*Unimplemented*/Option<Fundamental: Pointer>) {
    //    unsafe { TODO: call soup_sys:soup_message_set_chunk_allocator() }
    //}

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn set_first_party(&self, first_party: &mut URI) {
        unsafe {
            soup_sys::soup_message_set_first_party(self.as_ref().to_glib_none().0, first_party.to_glib_none_mut().0);
        }
    }

    //fn set_flags(&self, flags: /*Ignored*/MessageFlags) {
    //    unsafe { TODO: call soup_sys:soup_message_set_flags() }
    //}

    fn set_http_version(&self, version: HTTPVersion) {
        unsafe {
            soup_sys::soup_message_set_http_version(self.as_ref().to_glib_none().0, version.to_glib());
        }
    }

    #[cfg(any(feature = "v2_44", feature = "dox"))]
    fn set_priority(&self, priority: MessagePriority) {
        unsafe {
            soup_sys::soup_message_set_priority(self.as_ref().to_glib_none().0, priority.to_glib());
        }
    }

    #[cfg(any(feature = "v2_38", feature = "dox"))]
    fn set_redirect(&self, status_code: u32, redirect_uri: &str) {
        unsafe {
            soup_sys::soup_message_set_redirect(self.as_ref().to_glib_none().0, status_code, redirect_uri.to_glib_none().0);
        }
    }

    fn set_request(&self, content_type: Option<&str>, req_use: MemoryUse, req_body: &[u8]) {
        let req_length = req_body.len() as usize;
        unsafe {
            soup_sys::soup_message_set_request(self.as_ref().to_glib_none().0, content_type.to_glib_none().0, req_use.to_glib(), req_body.to_glib_none().0, req_length);
        }
    }

    fn set_response(&self, content_type: Option<&str>, resp_use: MemoryUse, resp_body: &[u8]) {
        let resp_length = resp_body.len() as usize;
        unsafe {
            soup_sys::soup_message_set_response(self.as_ref().to_glib_none().0, content_type.to_glib_none().0, resp_use.to_glib(), resp_body.to_glib_none().0, resp_length);
        }
    }

    fn set_status(&self, status_code: u32) {
        unsafe {
            soup_sys::soup_message_set_status(self.as_ref().to_glib_none().0, status_code);
        }
    }

    fn set_status_full(&self, status_code: u32, reason_phrase: &str) {
        unsafe {
            soup_sys::soup_message_set_status_full(self.as_ref().to_glib_none().0, status_code, reason_phrase.to_glib_none().0);
        }
    }

    fn set_uri(&self, uri: &mut URI) {
        unsafe {
            soup_sys::soup_message_set_uri(self.as_ref().to_glib_none().0, uri.to_glib_none_mut().0);
        }
    }

    fn starting(&self) {
        unsafe {
            soup_sys::soup_message_starting(self.as_ref().to_glib_none().0);
        }
    }

    fn wrote_body(&self) {
        unsafe {
            soup_sys::soup_message_wrote_body(self.as_ref().to_glib_none().0);
        }
    }

    //fn wrote_body_data(&self, chunk: /*Ignored*/&mut Buffer) {
    //    unsafe { TODO: call soup_sys:soup_message_wrote_body_data() }
    //}

    fn wrote_chunk(&self) {
        unsafe {
            soup_sys::soup_message_wrote_chunk(self.as_ref().to_glib_none().0);
        }
    }

    fn wrote_headers(&self) {
        unsafe {
            soup_sys::soup_message_wrote_headers(self.as_ref().to_glib_none().0);
        }
    }

    fn wrote_informational(&self) {
        unsafe {
            soup_sys::soup_message_wrote_informational(self.as_ref().to_glib_none().0);
        }
    }

    fn get_property_method(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"method\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `method` getter")
        }
    }

    fn set_property_method(&self, method: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"method\0".as_ptr() as *const _, Value::from(method).to_glib_none().0);
        }
    }

    fn get_property_priority(&self) -> MessagePriority {
        unsafe {
            let mut value = Value::from_type(<MessagePriority as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"priority\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `priority` getter").unwrap()
        }
    }

    fn set_property_priority(&self, priority: MessagePriority) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"priority\0".as_ptr() as *const _, Value::from(&priority).to_glib_none().0);
        }
    }

    fn get_property_reason_phrase(&self) -> Option<GString> {
        unsafe {
            let mut value = Value::from_type(<GString as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"reason-phrase\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `reason-phrase` getter")
        }
    }

    fn set_property_reason_phrase(&self, reason_phrase: Option<&str>) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"reason-phrase\0".as_ptr() as *const _, Value::from(reason_phrase).to_glib_none().0);
        }
    }

    //fn get_property_request_body(&self) -> /*Ignored*/Option<MessageBody> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"request-body\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `request-body` getter")
    //    }
    //}

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn get_property_request_body_data(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"request-body-data\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `request-body-data` getter")
        }
    }

    //fn get_property_request_headers(&self) -> /*Ignored*/Option<MessageHeaders> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"request-headers\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `request-headers` getter")
    //    }
    //}

    //fn get_property_response_body(&self) -> /*Ignored*/Option<MessageBody> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"response-body\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `response-body` getter")
    //    }
    //}

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn get_property_response_body_data(&self) -> Option<glib::Bytes> {
        unsafe {
            let mut value = Value::from_type(<glib::Bytes as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"response-body-data\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `response-body-data` getter")
        }
    }

    //fn get_property_response_headers(&self) -> /*Ignored*/Option<MessageHeaders> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"response-headers\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `response-headers` getter")
    //    }
    //}

    fn get_property_server_side(&self) -> bool {
        unsafe {
            let mut value = Value::from_type(<bool as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"server-side\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `server-side` getter").unwrap()
        }
    }

    fn get_property_status_code(&self) -> u32 {
        unsafe {
            let mut value = Value::from_type(<u32 as StaticType>::static_type());
            gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"status-code\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `status-code` getter").unwrap()
        }
    }

    fn set_property_status_code(&self, status_code: u32) {
        unsafe {
            gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"status-code\0".as_ptr() as *const _, Value::from(&status_code).to_glib_none().0);
        }
    }

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn get_property_tls_certificate(&self) -> /*Ignored*/Option<gio::TlsCertificate> {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-certificate\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `tls-certificate` getter")
    //    }
    //}

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn set_property_tls_certificate<P: IsA</*Ignored*/gio::TlsCertificate> + SetValueOptional>(&self, tls_certificate: Option<&P>) {
    //    unsafe {
    //        gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-certificate\0".as_ptr() as *const _, Value::from(tls_certificate).to_glib_none().0);
    //    }
    //}

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn get_property_tls_errors(&self) -> /*Ignored*/gio::TlsCertificateFlags {
    //    unsafe {
    //        let mut value = Value::from_type(</*Unknown type*/ as StaticType>::static_type());
    //        gobject_sys::g_object_get_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-errors\0".as_ptr() as *const _, value.to_glib_none_mut().0);
    //        value.get().expect("Return Value for property `tls-errors` getter").unwrap()
    //    }
    //}

    //#[cfg(any(feature = "v2_34", feature = "dox"))]
    //fn set_property_tls_errors(&self, tls_errors: /*Ignored*/gio::TlsCertificateFlags) {
    //    unsafe {
    //        gobject_sys::g_object_set_property(self.to_glib_none().0 as *mut gobject_sys::GObject, b"tls-errors\0".as_ptr() as *const _, Value::from(&tls_errors).to_glib_none().0);
    //    }
    //}

    //#[cfg(any(feature = "v2_28", feature = "dox"))]
    //fn connect_content_sniffed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Empty ctype params: *.HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }
    //}

    fn connect_finished<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn finished_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"finished\0".as_ptr() as *const _,
                Some(transmute(finished_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_got_body<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn got_body_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"got-body\0".as_ptr() as *const _,
                Some(transmute(got_body_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    //fn connect_got_chunk<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored chunk: Soup.Buffer
    //}

    fn connect_got_headers<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn got_headers_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"got-headers\0".as_ptr() as *const _,
                Some(transmute(got_headers_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_got_informational<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn got_informational_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"got-informational\0".as_ptr() as *const _,
                Some(transmute(got_informational_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v2_38", feature = "dox"))]
    //fn connect_network_event<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored event: Gio.SocketClientEvent
    //    Ignored connection: Gio.IOStream
    //}

    fn connect_restarted<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn restarted_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"restarted\0".as_ptr() as *const _,
                Some(transmute(restarted_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_50", feature = "dox"))]
    fn connect_starting<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn starting_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"starting\0".as_ptr() as *const _,
                Some(transmute(starting_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_wrote_body<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn wrote_body_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"wrote-body\0".as_ptr() as *const _,
                Some(transmute(wrote_body_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    //#[cfg(any(feature = "v2_24", feature = "dox"))]
    //fn connect_wrote_body_data<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Ignored chunk: Soup.Buffer
    //}

    fn connect_wrote_chunk<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn wrote_chunk_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"wrote-chunk\0".as_ptr() as *const _,
                Some(transmute(wrote_chunk_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_wrote_headers<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn wrote_headers_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"wrote-headers\0".as_ptr() as *const _,
                Some(transmute(wrote_headers_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_wrote_informational<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn wrote_informational_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"wrote-informational\0".as_ptr() as *const _,
                Some(transmute(wrote_informational_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    fn connect_property_first_party_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_first_party_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::first-party\0".as_ptr() as *const _,
                Some(transmute(notify_first_party_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_flags_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::flags\0".as_ptr() as *const _,
                Some(transmute(notify_flags_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_http_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_http_version_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::http-version\0".as_ptr() as *const _,
                Some(transmute(notify_http_version_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_method_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_method_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::method\0".as_ptr() as *const _,
                Some(transmute(notify_method_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_priority_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_priority_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::priority\0".as_ptr() as *const _,
                Some(transmute(notify_priority_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_reason_phrase_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_reason_phrase_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::reason-phrase\0".as_ptr() as *const _,
                Some(transmute(notify_reason_phrase_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_request_body_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_request_body_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::request-body\0".as_ptr() as *const _,
                Some(transmute(notify_request_body_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn connect_property_request_body_data_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_request_body_data_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::request-body-data\0".as_ptr() as *const _,
                Some(transmute(notify_request_body_data_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_request_headers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_request_headers_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::request-headers\0".as_ptr() as *const _,
                Some(transmute(notify_request_headers_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_response_body_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_response_body_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::response-body\0".as_ptr() as *const _,
                Some(transmute(notify_response_body_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_46", feature = "dox"))]
    fn connect_property_response_body_data_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_response_body_data_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::response-body-data\0".as_ptr() as *const _,
                Some(transmute(notify_response_body_data_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_response_headers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_response_headers_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::response-headers\0".as_ptr() as *const _,
                Some(transmute(notify_response_headers_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_status_code_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_status_code_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::status-code\0".as_ptr() as *const _,
                Some(transmute(notify_status_code_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_34", feature = "dox"))]
    fn connect_property_tls_certificate_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tls_certificate_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tls-certificate\0".as_ptr() as *const _,
                Some(transmute(notify_tls_certificate_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_34", feature = "dox"))]
    fn connect_property_tls_errors_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_tls_errors_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::tls-errors\0".as_ptr() as *const _,
                Some(transmute(notify_tls_errors_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }

    fn connect_property_uri_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uri_trampoline<P, F: Fn(&P) + 'static>(this: *mut soup_sys::SoupMessage, _param_spec: glib_sys::gpointer, f: glib_sys::gpointer)
            where P: IsA<Message>
        {
            let f: &F = &*(f as *const F);
            f(&Message::from_glib_borrow(this).unsafe_cast())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::uri\0".as_ptr() as *const _,
                Some(transmute(notify_uri_trampoline::<Self, F> as usize)), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Message {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Message")
    }
}
